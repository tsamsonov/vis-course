[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Визуализация пространственных данных",
    "section": "",
    "text": "Добро пожаловать на курс “Визуализация пространственных данных”! В этом курсе мы научимся создавать карты программным путём, используя возможности QGIS."
  },
  {
    "objectID": "01_Basics.html",
    "href": "01_Basics.html",
    "title": "1  Базовые операции рендеринга",
    "section": "",
    "text": "Визуализация данных в QGIS возможна не только посредством графического интерфейса, но также путем программной компоновки карт. Преимущество программного отображения в QGIS по сравнению с тем, что вы можете сделать на чистом Python — в том, что становится доступен невероятно мощный функционал и производительность графического движка QGIS.\nПервая операция, которая может быть полезной, это получение ссылки на экземпляр проекта:\n\nQgsProject.instance()\n\nГлавное, для чего он может быть полезен — это управление списком отображаемых слоёв. Можно получить список слоев или удалить все слои из содержимого карты:\n\nQgsProject.instance().mapLayers().values() # список слоёв\nQgsProject.instance().removeAllMapLayers() # удаление всех слоёв\n\nЕсли необходимо чтобы скрипт собирал карту с нуля каждый раз при запуске, следует расположить вызов removeAllMapLayers() в самом начале. Это будет гарантировать, что сборка проекта начнется с чистого листа.\nСборку логично начать с добавления слоёв, которое осуществляется посредством следующей команды:\n\nlayer = iface.addVectorLayer(path)\nlayer = iface.addRasterLayer(path)\n\nгде path — полный путь к данным, layer — переменная, которая будет хранить ссылку на слой в таблице содержания. Вы можете ее называть любым подходящим именем.\nОбратите внимание на переменную iface. Это самая важная переменная в скрипте. Создавать её не нужно, она доступна всегда по умолчанию и представляет собой экземпляр класса QgsInterface. Через него вы получаете доступ к компоненте карты, меню, панелям инструментов и другим компонентам.\nПосле того как слой добавлен на карту, можно заниматься его оформлением. Для того необходимо получить символику:\n\nsymbol = layer.renderer().symbol()\n\nВ целом, не обязательно записывать символ в какую-то переменную, но если вы планируете осуществлять более чем одну настройку символа, то лучше это сделать, чтобы каждый раз не вызывать указанную последовательность функций.\nЧасть функций по оформлению слоя доступна непосредственно через объект символа. Например, глобальный цвет, толщину линии или размер пунсона можно задать следующим образом:\n\nsymbol.setColor(color) # заливка\nsymbol.setWidth(width) # толщина\nsymbol.setSize(size)   # размер\n\nгде color — объект класса QColor, определяющий цвет (см. далее).\nБольшинство же настроек символики делается через слои символов, извлечь каждый из которых можно следующим образом:\n\nsymbol.symbolLayer(i)\n\nгде i — номер слоя символа. По умолчанию каждый символ имеет один слой с индексом 0. Для доступа к нему соответственно надо вызвать symbol.symbolLayer(0).\nНапример, цвет и паттерн линии или обводки полигона устанавливаются так:\n\nsymbol.symbolLayer(0).setStrokeColor(color) # цвет линии\nsymbol.symbolLayer(0).setStrokeStyle(style) # паттерн линии\n\nгде style — экземпляр класс PenStyle.\nДля создания цветов и стилей линий существуют свои классы. Цвет можно создать по названию или цветовым компонентам:\n\ncolor = QColor('azure')\ncolor = QColor(120, 240, 75)\n\nА вот создание стиля линии делается не через нативные классы QGIS, а посредством классов библиотеки Qt, на которой реализован вообще весь QGIS:\n\nstyle = Qt.PenStyle(Qt.NoPen) # Нет обводки\nstyle = Qt.PenStyle(Qt.DotLine) # Пунктир\nstyle = Qt.PenStyle(Qt.SolidLine) # Сплошная\n\nПолный перечень стилей Qt согласно официальной документации выглядит так:\n\n\n\nСтили линий Qt\n\n\nПосле того как вы настроили внешний вид слоя, необходимо сделать 2 вещи: инициировать его перерисовку на карте, а также обновить его легенду, для того чтобы она соответствовала символике. Делается это следующим образом:\n\nlayer.triggerRepaint() # перерисовать слой\niface.layerTreeView().refreshLayerSymbology(layer.id()) # обновить легенду\n\nОбратите внимание на то, что легендой слоя владеет не сам слой, а компонента таблицы содержания (layerTreeView).\nКоманды перерисовки карты и легенды должны быть вызваны для каждого слоя, оформление которого изменено программным путём. Если необходимо одинаковым образом обновить все слои карты (например, задать им прозрачность или покрасить в черный цвет), то это можно сделать в цикле:\n\nlayers = QgsProject.instance().mapLayers().values()\nfor layer in layers:\n  ... # изменение символики\n  ... # изменение символики\n  layer.triggerRepaint()\n  iface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "objectID": "01_Basics.html#пример-использования",
    "href": "01_Basics.html#пример-использования",
    "title": "1  Базовые операции рендеринга",
    "section": "1.2 Пример использования",
    "text": "1.2 Пример использования\nВ данном примере рассматривается добавление на карту и раскрашивание полигона суши:\n\nQgsProject.instance().removeAllMapLayers()\ndb = '/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg|layername={layer}'\n\nland = db.format(layer='ne_110m_land')\n\nlayer = iface.addVectorLayer(land,'','ogr')\n\nfill = QColor (250,250,250)\nstroke = QColor('darkblue')\n\nsymbol = layer.renderer().symbol()\nsymbol.setColor(fill)\npen = Qt.PenStyle(Qt.SolidLine)\nsymbol.symbolLayer(0).setStrokeStyle(pen)\nsymbol.symbolLayer(0).setStrokeColor(stroke)\n\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())\n\nРезультат выглядит следующим образом:\n\n\n\nПрограммное добавление полигона суши в QGIS"
  }
]