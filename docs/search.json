[
  {
    "objectID": "01_BasicAlgorithms.html#компьютерная-графика",
    "href": "01_BasicAlgorithms.html#компьютерная-графика",
    "title": "Основы компьютерной графики",
    "section": "Компьютерная графика",
    "text": "Компьютерная графика\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\nВизуальный аспект: компьютер → человек\nИнтерактивный аспект: человек → компьютер"
  },
  {
    "objectID": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "href": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "title": "Основы компьютерной графики",
    "section": "Связь с компьютерным зрением",
    "text": "Связь с компьютерным зрением\nКомпьютерная графика: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\nКомпьютерное зрение: определение параметров сцены и погруженных в нее объектов при заданных допущениях.\n\n[Lesage, Visvalingam, 2002]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер",
    "href": "01_BasicAlgorithms.html#графический-конвейер",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВ статичной сцене графический конвейер определяет последовательность отрисовки изображения."
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер-1",
    "href": "01_BasicAlgorithms.html#графический-конвейер-1",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВзаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения"
  },
  {
    "objectID": "01_BasicAlgorithms.html#структура-2d-приложения",
    "href": "01_BasicAlgorithms.html#структура-2d-приложения",
    "title": "Основы компьютерной графики",
    "section": "Структура 2D-приложения",
    "text": "Структура 2D-приложения\n\n\n\n\n\nГрафическая платформа отвечает за взаимодействие приложения и оборудования\nМодель приложения (application model) представляет визуализируемые данные\nКлиентская область (client area) определяет пространство, в котором приложение выполняет отрисовку.\nПорт просмотра (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели"
  },
  {
    "objectID": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "href": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "title": "Основы компьютерной графики",
    "section": "Эволюция графической платформы",
    "text": "Эволюция графической платформы\n1980-е — начало 1990-х (Apple QuickDraw, Microsoft GDI): отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка примитивов: геометрических форм или битмапов (пиксельных карт).\n\nКаждый примитив заполняется путем вызова определенной функции (например, FillRectangle).\nРазмер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.\n\nСередина 1990-х — н.вр. Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат."
  },
  {
    "objectID": "01_BasicAlgorithms.html#непосредственный-режим",
    "href": "01_BasicAlgorithms.html#непосредственный-режим",
    "title": "Основы компьютерной графики",
    "section": "Непосредственный режим",
    "text": "Непосредственный режим\nВ непосредственном режиме (immediate mode) клиент через графическую платформу обращается непосредственно к выводящему устройству.\n\nЗапись примитивов, переданных приложением, не выполняется.\nПри смене сцены приложение должно перерисовать ее целиком."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сохраненный-режим",
    "href": "01_BasicAlgorithms.html#сохраненный-режим",
    "title": "Основы компьютерной графики",
    "section": "Сохраненный режим",
    "text": "Сохраненный режим\nВ сохраненном режиме (retained mode) графическая платформа хранит спецификацию сцены в виде графа сцены (scene graph).\n\nОбъекты могут добавляться в граф сцены последовательно.\nКаждое изменение графа приводит к перерисовке сцены"
  },
  {
    "objectID": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "href": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "title": "Основы компьютерной графики",
    "section": "Процедурный и декларативный подходы",
    "text": "Процедурный и декларативный подходы\n\n\nПроцедурный код пишется на императивном языке программирования\n\nОписывает действия\nСтандарт при взаимодействии с графической платформой\nВ геоинформационных пакетах применяется на низком уровне, невидимом для пользователя\n\n\nДекларативные спецификации фиксируются на языке разметки\n\nОписывают результаты\nВспомогательное средство в графических платформах\nВ геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "href": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка векторных объектов",
    "text": "Отрисовка векторных объектов\n\nДве основных операции: обводка и заливка\nВ случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\nУстановить тип отображаемого объекта\nОрганизовать обход по всем уровням вложенности с помощью цикла\nНа самом низком уровне вложенности получить матрицу координат.\nПоследовательно соединяя соседние координаты в матрице, отрисовать границу отрезками."
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\nАлгоритм Брезенхема (Bresenham 1965)\ndraw_line(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nCистема экранных координат \\(ij\\), где \\(i\\) — строка (увеличивается сверху вниз), \\(j\\) — столбец (увеличивается слева направо),\n\n\\((i_0, j_0)\\) — начальная точка отрезка в экранных координатах\n\\((i_1, j_1)\\) — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: \\[\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}\\]\nВыразив \\(i\\), получаем: \\[i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\n\n\nСтандартно рассматривается отрисовка линии, которая располагается в секторе В-ЮВ, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 &lt; j_1,~i_0 \\leq i_1\\);\n\\(j_1 - j_0 \\geq i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора В-ЮВ алгоритм опирается на координаты \\(x\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{blue}{d = di / dj}\\);\n\\(\\color{blue}{i = i_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{blue}{j = j_0, ... j_1}\\), выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{blue}{i = i + \\texttt{sign}(di)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора В-СВ (только \\(i\\) будет уменьшаться).\nОбозначим случай draw_line_byJ(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\n\n\nАльтернативно рассматривается отрисовка линии, которая располагается в секторе Ю-ЮВ, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 \\leq j_1,~i_0 &lt; i_1\\);\n\\(j_1 - j_0 &lt; i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора Ю-ЮВ алгоритм опирается на координаты \\(i\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{red}{d = dj / di}\\);\n\\(\\color{red}{j = j_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{red}{i = i_0, ... i_1}\\) выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{red}{j = j + \\texttt{sign}(dj)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора Ю-ЮЗ (только \\(j\\) будет уменьшаться).\nОбозначим случай draw_line_byI(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на Python:\ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) &lt; abs(j1 - j0): # пологая линия\n        if j0 &gt; j1:\n            draw_line_byJ(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byJ(i0, j0, i1, j1, image, color)\n    else:\n        if i0 &gt; i1:                 # крутая линия\n            draw_line_byI(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byI(i0, j0, i1, j1, image, color)\nгде abs() — функция вычисления модуля."
  },
  {
    "objectID": "01_BasicAlgorithms.html#заливка-полигона",
    "href": "01_BasicAlgorithms.html#заливка-полигона",
    "title": "Основы компьютерной графики",
    "section": "Заливка полигона",
    "text": "Заливка полигона"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "href": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм сканирующей линии",
    "text": "Алгоритм сканирующей линии\nДля каждого \\(i_k = i_{min},...,i_{max}\\) получить упорядоченное по возрастанию множество \\(J = \\{j_0, j_1, ..., j_{n-1}\\}\\) столбцов пересечений с исходными линиями:\n\nДля каждой линии \\(l_m, m = 0,...,N-1\\):\n\n\nвычислить флаг пересечения \\(f: i^m_0 &gt; i_k \\neq i^m_1 &gt; i_k\\);\nесли \\(f = \\texttt{TRUE}\\), то\n\nвычислить \\(j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}\\);\nдобавить \\(j^m\\) в множество \\(J\\).\n\n\n\nЕсли \\(J\\) не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n\\[\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отсечение-отрезков",
    "href": "01_BasicAlgorithms.html#отсечение-отрезков",
    "title": "Основы компьютерной графики",
    "section": "Отсечение отрезков",
    "text": "Отсечение отрезков\nОдин из самых широко используемых — алгоритм Коэна-Сазерленда, в котором используется разбиение плоскости на 9 частей прямыми, координаты которых определяются границами прямоугольника (в частности — порта просмотра):\n\n\n\n\n\nINSIDE = 0 — \\(0000\\)\nLEFT = 1 — \\(0001\\)\nRIGHT = 2 — \\(0010\\)\nBOTTOM = 4 — \\(0100\\)\nTOP = 8 — \\(1000\\)\n\nОтрезки, обе точки которых находятся по одну сторону от прямоугольника, имеют совпадающий единичный бит в одной и той же позиции"
  },
  {
    "objectID": "01_BasicAlgorithms.html#вычисление-кодов-коэна-сазерленда",
    "href": "01_BasicAlgorithms.html#вычисление-кодов-коэна-сазерленда",
    "title": "Основы компьютерной графики",
    "section": "Вычисление кодов Коэна-Сазерленда",
    "text": "Вычисление кодов Коэна-Сазерленда\nПусть дана точка \\((i, j)\\), а также границы порта просмотра \\((i_{min}, i_{max})\\), \\((j_{min}, j_{max})\\).\nТогда код вычисляется следующим образом:\ndef code(i, j, imax, jmax):\n    code = INSIDE\n    if j &lt; jmin:\n        code |= LEFT\n    elif j &gt; jmax:\n        code |= RIGHT\n    if i &lt; imin:\n        code |= BOTTOM\n    elif i &gt; imax:\n        code |= TOP\n    return code\nВ данном случае применяется операция логическое ИЛИ, которая устанавливает в каждый бит \\(1\\), если хотя бы у одного из операндов соответствующий бит равен \\(1\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-коэна-сазерленда",
    "href": "01_BasicAlgorithms.html#алгоритм-коэна-сазерленда",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Коэна-Сазерленда",
    "text": "Алгоритм Коэна-Сазерленда\nДля каждого отрезка \\((i_0, j_0), (i_1, j_1)\\) выполняется бесконечный цикл, внутри которого ведутся следующие действия:\n\nВычисляются коды code0 и code1 для концов отрезка.\nЕсли оба конца находятся внутри порта просмотра (code0 | code1 == 0), то отрезок принимается целиком и цикл прерывается.\nЕсли оба конца находятся по одну сторону от порта просмотра (code0 & code1 != 0), то отрезок отклоняется целиком и цикл прерывается.\nВ противном случае (оба конца находятся по разные стороны от порта просмотра), выполняются следующие действия:\n\nВыбирается любая точка, находящаяся за пределами порта просмотра.\nВыполняется пересечение отрезка с прямой, определяющей ту сторону, в которой находится выбранная точка.\nВыбранная точка заменяется на найденное пересечение."
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nАффинное преобразование \\(f\\colon\\mathbb{R}^{n}\\to \\mathbb{R}^{n}\\) есть преобразование вида:\n\\[\nf(\\mathrm p) = \\mathbf M \\cdot \\mathrm p + \\mathrm v\n\\]\nгде \\(\\mathbf M\\) — обратимая матрица (квадратная матрица, определитель которой отличен от нуля) и \\(v\\in \\mathbb{R}^{n}\\).\n\\(\\mathbf M\\) и \\(\\mathrm v\\) обычно объединяются в одну матрицу \\(\\mathbf A\\), что требует представления \\(p\\) в однородных координатах: \\(\\widehat{\\mathrm p} = (x_p, y_p,..., 1)\\). В этом случае аффинное преобразование можно записать как:\n\\[\nf(\\mathrm p) = \\mathbf A \\cdot \\widehat{\\mathrm p} = \\left[ \\begin{array}{ccc|c} \\, & \\mathbf M & & \\mathrm v \\ \\\\ 0 & \\ldots & 0 & 1 \\end{array} \\right] \\begin{bmatrix} \\mathrm p \\\\ 1 \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования-1",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования-1",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nСдвиг на вектор трансляции \\(t = (t_x, t_y)\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} 1 &  0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf T(t_x, t_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1x + 0y + t_x1 \\\\ 0x + 1y + t_y1 \\\\ 0x + 0y + 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix},\n\\]\nПоворот на угол \\(\\theta\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 0 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} \\cos \\theta &  -\\sin \\theta & 0 \\\\ \\sin \\theta & \\cos \\theta  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf R(\\theta)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta \\\\ x \\sin \\theta + y \\cos \\theta \\\\ 1 \\end{bmatrix},\n\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования-2",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования-2",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nМасштабирование с коэффициентами \\(s_x, s_y\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} s_x &  0 & 0 \\\\ 0 & s_y  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf S(s_x, s_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x s_x \\\\ y s_y \\\\ 1 \\end{bmatrix},\n\\]\n\nпри навигации по карте \\(s_x = s_y = a\\)\nдля зеркального отражения по соответствующим осям \\(s_x\\) или \\(s_y\\) будут иметь отрицательные значения."
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\nПри загрузке слоя данных в пустой проект объекты вписываются в порт просмотра.\nПусть ограничивающий прямоугольник (экстент) данных имеет размеры \\([x_0, y_0]\\times[x_1, y_1]\\), а размер порта просмотра \\([0, di]\\times[0, dj]\\). Тогде необходимо выполнить следующие преобразования:\n\nСовместить начало координат с центром экстента данных — точкой \\([(x_1 + x_0)/2, (y_1 + y_0)/2]\\).\nНа оcнове сравнения пропорций экстента \\(\\frac{dy}{dx}\\) и порта просмотра \\(\\frac{di}{dj}\\) выбрать коэффициент масштабирования \\(s\\):\n\n\\[s = \\begin{cases}\n\\frac{dj}{dx},~\\texttt{если}~\\frac{dy}{dx} \\leq \\frac{di}{dj}\\\\\n\\frac{di}{dy},~\\texttt{если}~\\frac{dy}{dx} &gt; \\frac{di}{dj}\\\\\n\\end{cases}\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии-1",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии-1",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\n\nОтмасштабировать координаты на полученный коэффициент \\(s\\).\nПереместить отмасштабированное изображение в точку \\((di/2, dj/2)\\).\n\nИтоговая матрица преобразования \\(\\textbf{A}\\) будет выглядеть следующим образом:\n\\[\\textbf A = \\textbf T(di/2, dj/2)~\\textbf S(s)~\\textbf T(-(x_1 + x_0)/2, -(y_1 + y_0)/2)\\]\nТочки исходных объектов \\(p\\) будут трансформированы в точки внутри порта просмотра \\(p'\\) как:\n\\[p' = \\textbf A p\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии-2",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии-2",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\nПусть текущая матрица отображения равна \\(A\\). Пользователь:\n\nперетащил изображение из точки \\((i_1, j_1)\\) в точку \\((i_2, j_2)\\):\n\n\\[\\mathbf A = \\mathbf T(i_2-i_1, j_2 - j_1)\\mathbf A\\]\n\nв точке \\((i, j)\\) прокрутил колесико мыши на \\(k &gt; 0\\) оборота:\n\n\\[\\mathbf A = \\mathbf T(i, j)~\\mathbf S(ks, ks)~\\mathbf T(-i, -j)~\\mathbf A\\]\n\nв точке \\((i, j)\\) прокрутил колесико мыши на \\(k &lt; 0\\) оборота:\n\n\\[\\mathbf A = \\mathbf T(i, j)~\\mathbf S(-\\frac{1}{ks}, -\\frac{1}{ks})~\\mathbf T(-i, -j)~\\mathbf A\\]\nКаждый оборот соответствует изменению масштаба в \\(s\\) раз. Отрицательные обороты соответствуют уменьшению масштаба, положительные — увеличению."
  },
  {
    "objectID": "01_BasicAlgorithms.html#передискретизация-resampling",
    "href": "01_BasicAlgorithms.html#передискретизация-resampling",
    "title": "Основы компьютерной графики",
    "section": "Передискретизация (resampling)",
    "text": "Передискретизация (resampling)\nПередискретизация необходима при визуализации растрового изображения на растровом экране. Как правило, разрешение этих растров не совпадает."
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-ближайшего-соседа",
    "href": "01_BasicAlgorithms.html#метод-ближайшего-соседа",
    "title": "Основы компьютерной графики",
    "section": "Метод ближайшего соседа",
    "text": "Метод ближайшего соседа\nИспользуется значение ближайшего пикселя:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-билинейной-интерполяции",
    "href": "01_BasicAlgorithms.html#метод-билинейной-интерполяции",
    "title": "Основы компьютерной графики",
    "section": "Метод билинейной интерполяции",
    "text": "Метод билинейной интерполяции\nВосстанавливается поверхность в ячейке из 4 узлов:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-билинейной-интерполяции-1",
    "href": "01_BasicAlgorithms.html#метод-билинейной-интерполяции-1",
    "title": "Основы компьютерной графики",
    "section": "Метод билинейной интерполяции",
    "text": "Метод билинейной интерполяции\n\n\n\n\nКоэффициенты определяются по 4 точкам:\n\\[\\begin{cases}\na_{00} = f_{00},\\\\\na_{10} = f_{10} - f_{00},\\\\\na_{01} = f_{01} - f_{00},\\\\\na_{01} = f_{00} + f_{11} - f_{10} - f_{01}.\n\\end{cases}\\]\n\\[f(x, y) = a_{00} + a_{10}x + a_{01}y + a_{11}xy\\]\nКоординаты \\(x\\) и \\(y\\) меняются в диапазоне от \\(0\\) до \\(1\\) в пределах ячейки."
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-бикубической-интерполяции",
    "href": "01_BasicAlgorithms.html#метод-бикубической-интерполяции",
    "title": "Основы компьютерной графики",
    "section": "Метод бикубической интерполяции",
    "text": "Метод бикубической интерполяции\nВосстанавливается поверхность в 9 ячейках, окружающих узел:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-бикубической-интерполяции-1",
    "href": "01_BasicAlgorithms.html#метод-бикубической-интерполяции-1",
    "title": "Основы компьютерной графики",
    "section": "Метод бикубической интерполяции",
    "text": "Метод бикубической интерполяции\n\n\n\n\nКоэффициенты определяются по 16 точкам:\n\\[\\begin{cases}\nf(0,0) = a_{00},\\\\\nf(1,0) = a_{00} + a_{10} + a_{20} + a_{30},\\\\\nf(0,1) = a_{00} + a_{01} + a_{02} + a_{03},\\\\\nf(1,1) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij},\\\\\n\\dots\n\\end{cases}\\]\n\\[f(x, y) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij} x^i y^j\\]\nКоординаты \\(x\\) и \\(y\\) меняются в диапазоне от \\(0\\) до \\(1\\) в пределах окрестности \\(3 \\times 3\\) ячеек."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сглаживание-antialiasing",
    "href": "01_BasicAlgorithms.html#сглаживание-antialiasing",
    "title": "Основы компьютерной графики",
    "section": "Сглаживание (antialiasing)",
    "text": "Сглаживание (antialiasing)\nПри крупном размере пиксела выводящего устройства ступенчатость линий и границ полигонов становится заметной.\nДля устранения эффекта ступенчатости используется сглаживание (antialiasing)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сглаживание-antialiasing-1",
    "href": "01_BasicAlgorithms.html#сглаживание-antialiasing-1",
    "title": "Основы компьютерной графики",
    "section": "Сглаживание (antialiasing)",
    "text": "Сглаживание (antialiasing)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#суперсемплинг-antialiasing",
    "href": "01_BasicAlgorithms.html#суперсемплинг-antialiasing",
    "title": "Основы компьютерной графики",
    "section": "Суперсемплинг (antialiasing)",
    "text": "Суперсемплинг (antialiasing)\nПусть результирующее растровое изображение \\(R\\) имеет размеры \\(m \\times n\\).\n\nСоздается буферное изображение \\(R_b\\) размером \\(km \\times kn\\), где \\(k \\in \\mathbb{N^*}\\) — коэффициент сглаживания (положительное натуральное число).\nОбъекты отрисовываются в \\(R_b\\).\nПроизводится передискретизация \\(R_b \\to R\\) с использованием блочной фильтрации (box filter). Значение результирующего пиксела \\(R[i, j]\\) равняется среднему арифметическому значений \\(R_b\\), попадающих в его пределы:\n\n\\[R[i, j] = \\sum_{l = 1}^L s(R_b) / L,\\]\nгде \\(s(R_b)\\) — выборочное значение (сэмпл), взятое с \\(R_b\\), \\(L\\) — количество сэмплов"
  },
  {
    "objectID": "01_BasicAlgorithms.html#библиография",
    "href": "01_BasicAlgorithms.html#библиография",
    "title": "Основы компьютерной графики",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций\n\n\n\n\nBresenham, J. E. 1965. «Algorithm for Computer Control of a Digital Plotter». IBM Systems Journal 4 (1): 25–30. https://doi.org/10.1147/sj.41.0025."
  }
]