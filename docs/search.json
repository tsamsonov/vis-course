[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Визуализация пространственных данных",
    "section": "",
    "text": "Введение\nДобро пожаловать на курс “Визуализация пространственных данных”! В этом курсе мы научимся создавать карты программным путём, используя возможности QGIS."
  },
  {
    "objectID": "p01_Basics.html#функции-qgis",
    "href": "p01_Basics.html#функции-qgis",
    "title": "1  Базовые операции рендеринга",
    "section": "1.1 Функции QGIS",
    "text": "1.1 Функции QGIS\nВизуализация данных в QGIS возможна не только посредством графического интерфейса, но также путем программной компоновки карт. Преимущество программного отображения в QGIS по сравнению с тем, что вы можете сделать на чистом Python — в том, что становится доступен невероятно мощный функционал и производительность графического движка QGIS.\n\n1.1.1 Добавление и удаление слоёв\nПервая операция, которая может быть полезной, это получение ссылки на экземпляр проекта:\n\nQgsProject.instance()\n\nГлавное, для чего он может быть полезен — это управление списком отображаемых слоёв. Можно получить список слоев или удалить все слои из содержимого карты:\n\nQgsProject.instance().mapLayers().values() # список слоёв\nQgsProject.instance().removeAllMapLayers() # удаление всех слоёв\n\nЕсли необходимо чтобы скрипт собирал карту с нуля каждый раз при запуске, следует расположить вызов removeAllMapLayers() в самом начале. Это будет гарантировать, что сборка проекта начнется с чистого листа.\nСборку логично начать с добавления слоёв, которое осуществляется посредством следующей команды:\n\nlayer = iface.addVectorLayer(path)\nlayer = iface.addRasterLayer(path)\n\nгде path — полный путь к данным, layer — переменная, которая будет хранить ссылку на слой в таблице содержания. Вы можете ее называть любым подходящим именем.\nОбратите внимание на переменную iface. Это самая важная переменная в скрипте. Создавать её не нужно, она доступна всегда по умолчанию и представляет собой экземпляр класса QgsInterface. Через него вы получаете доступ к компоненте карты, меню, панелям инструментов и другим компонентам.\n\n\n1.1.2 Символика\nПосле того как слой добавлен на карту, можно заниматься его оформлением. Для того необходимо получить символику:\n\nsymbol = layer.renderer().symbol()\n\nВ целом, не обязательно записывать символ в какую-то переменную, но если вы планируете осуществлять более чем одну настройку символа, то лучше это сделать, чтобы каждый раз не вызывать указанную последовательность функций.\nЧасть функций по оформлению слоя доступна непосредственно через объект символа. Например, глобальный цвет, толщину линии или размер пунсона можно задать следующим образом:\n\nsymbol.setColor(color) # заливка\nsymbol.setWidth(width) # толщина\nsymbol.setSize(size)   # размер\n\nгде color — объект класса QColor, определяющий цвет (см. далее).\nБольшинство же настроек символики делается через слои символов, извлечь каждый из которых можно следующим образом:\n\nsymbol.symbolLayer(i)\n\nгде i — номер слоя символа. По умолчанию каждый символ имеет один слой с индексом 0. Для доступа к нему соответственно надо вызвать symbol.symbolLayer(0).\nНапример, цвет и паттерн линии или обводки полигона устанавливаются так:\n\nsymbol.symbolLayer(0).setStrokeColor(color) # цвет линии\nsymbol.symbolLayer(0).setStrokeStyle(style) # паттерн линии\n\nгде style — экземпляр класс PenStyle.\nДля создания цветов и стилей линий существуют свои классы. Цвет можно создать по названию или цветовым компонентам:\n\ncolor = QColor('azure')\ncolor = QColor(120, 240, 75)\n\nА вот создание стиля линии делается не через нативные классы QGIS, а посредством классов библиотеки Qt, на которой реализован вообще весь QGIS:\n\nstyle = Qt.PenStyle(Qt.NoPen) # Нет обводки\nstyle = Qt.PenStyle(Qt.DotLine) # Пунктир\nstyle = Qt.PenStyle(Qt.SolidLine) # Сплошная\n\nПолный перечень стилей Qt согласно официальной документации выглядит так:\n\n\n\nСтили линий Qt\n\n\n\n\n1.1.3 Подписи\nДля того чтобы включить подписи слоя, необходимо сделать ряд настроек. Для начала следует получить экземпляры классов, отвечающих за настройки слоя в целом и форматирование текста в частности:\n\nsettings  = QgsPalLayerSettings()\ntext_format = QgsTextFormat()\n\nДалее осуществляется последовательная настройка подписей:\n\ntext_format.setFont(QFont(\"Arial\", 14))\ntext_format.setSize(14)\n\nsettings.enabled = True\nsettings.fieldName = \"NAME\"\nsettings.setFormat(text_format)\n\nНа основе полученных настроек необходимо инициализировать класс подписей и назначить его слою:\n\nlabeling = QgsVectorLayerSimpleLabeling(settings)\nlayer.setLabelsEnabled(True)\nlayer.setLabeling(labeling)\n\n\n\n1.1.4 Фильтрация\nЧтобы осуществить фильтрацию слоя по атрибуту, достаточно активировать соответствующую настройку посредством setSubsetString:\n\nlayer.setSubsetString(\"SIZE &gt; 2000\")\n\n\n\n1.1.5 Перерисовка карты и легенды\nПосле того как вы настроили внешний вид слоя, необходимо сделать 2 вещи: инициировать его перерисовку на карте, а также обновить его легенду, для того чтобы она соответствовала символике. Делается это следующим образом:\n\nlayer.triggerRepaint() # перерисовать слой\niface.layerTreeView().refreshLayerSymbology(layer.id()) # обновить легенду\n\nОбратите внимание на то, что легендой слоя владеет не сам слой, а компонента таблицы содержания (layerTreeView).\nКоманды перерисовки карты и легенды должны быть вызваны для каждого слоя, оформление которого изменено программным путём. Если необходимо одинаковым образом обновить все слои карты (например, задать им прозрачность или покрасить в черный цвет), то это можно сделать в цикле:\n\nlayers = QgsProject.instance().mapLayers().values()\nfor layer in layers:\n  ... # изменение символики\n  ... # изменение символики\n  layer.triggerRepaint()\n  iface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "objectID": "p01_Basics.html#пример-использования",
    "href": "p01_Basics.html#пример-использования",
    "title": "1  Базовые операции рендеринга",
    "section": "1.2 Пример использования",
    "text": "1.2 Пример использования\nВ данном примере рассматривается добавление на карту и раскрашивание полигона суши:\n\nQgsProject.instance().removeAllMapLayers()\nland = '/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg|layername=ne_110m_land'\n\nlayer = iface.addVectorLayer(land,'','ogr')\n\nfill = QColor (250,250,250)\nstroke = QColor('darkblue')\n\nsymbol = layer.renderer().symbol()\nsymbol.setColor(fill)\npen = Qt.PenStyle(Qt.SolidLine)\nsymbol.symbolLayer(0).setStrokeStyle(pen)\nsymbol.symbolLayer(0).setStrokeColor(stroke)\n\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())\n\nРезультат выглядит следующим образом:\n\n\n\nПрограммное добавление полигона суши в QGIS"
  },
  {
    "objectID": "p02_Scales.html#доступ-к-атрибутивным-полям",
    "href": "p02_Scales.html#доступ-к-атрибутивным-полям",
    "title": "2  Создание шкал",
    "section": "2.1 Доступ к атрибутивным полям",
    "text": "2.1 Доступ к атрибутивным полям\nЧтобы узнать перечень атрибутов, можно использовать метод fields():\n\nfields = [field.name for field in layer.fields()]\nprint(fields)\n\nАналогичным образом можно вытащить все значения атрибута:\n\nadmin = [feature[\"ADMIN\"] for feature in layer.getFeatures()]\nprint(admin)"
  },
  {
    "objectID": "p02_Scales.html#формирование-интервалов",
    "href": "p02_Scales.html#формирование-интервалов",
    "title": "2  Создание шкал",
    "section": "2.2 Формирование интервалов",
    "text": "2.2 Формирование интервалов\nДанный метод может использоваться дли автоматизации таких способов как картограммы, картодиаграммы, значки. В этом упражнении мы рассмотрим как создать каждый интервал классификации вручную.\nПрежде всего необходимо понимать, какой тип геометрии у слоя:\n\ngeom_type = layer.geometryType()\n\nДалее нужно создать пустой список интервалов классификации:\n\nranges = []\n\nЕсли известно количество классов (N), которое необходимо получить, следует заполнить этот список объектами интервалов. Для каждого интервала надо вычислить его цвет, минимальную и максимальную границу, а также подпись (то, что будет отображаться в легенде). Далее на основе этих данных создается объект символа (QgsSymbol) и объект интервала (QgsRendererRange), который добавляется в список интеовалов. Примерный шаблон кода выглядит следующим образом:\n\nfor i in range(N):\n  col = ...\n  low = ...\n  high = ...\n  label = ...\n  \n  sym = QgsSymbol.defaultSymbol(geom_type)\n  sym.setColor(col)\n  interval = QgsRendererRange(low, high, sym, label)\n  \n  ranges.append(interval)\n\nДалее на основе созданных интервалов можно уже соорудить визуализатор градуированных символов:\n\nrenderer = QgsGraduatedSymbolRenderer('POP_EST', ranges)"
  },
  {
    "objectID": "p02_Scales.html#назначение-ручного-метода-классификации",
    "href": "p02_Scales.html#назначение-ручного-метода-классификации",
    "title": "2  Создание шкал",
    "section": "2.3 Назначение ручного метода классификации",
    "text": "2.3 Назначение ручного метода классификации\nЧтобы визуализатор заработал, необходимо выбрать, к какому методу классификации относятся выбранные вами границы. Поскольку они сформированы вручную, нужно выбрать соответствующий метод:\n\nclassreg = QgsApplication.classificationMethodRegistry()\nnms = classreg.methodNames()\nprint(nms)\n\nБудет выведено нечто следующее:\n{'Equal Count (Quantile)': 'Quantile', 'Equal Interval': 'EqualInterval', 'Fixed Interval': 'Fixed', 'Logarithmic Scale': 'Logarithmic', 'Natural Breaks (Jenks)': 'Jenks', 'Pretty Breaks': 'Pretty', 'Standard Deviation': 'StdDev'}\nС методами автоматической классификации мы познакомимся далее. А пока что надо выбрать вариант Fixed или EqualInterval и присвоить его визуализатору:\n\nmethod = classreg.method('Fixed')\nrenderer.setClassificationMethod(method)\n\nНаконец, после того как визуализатор готов, его нажно назначить слою и обновить изображение:\n\nlayer.setRenderer(renderer)\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "objectID": "p03_Colordist.html#установка-модуля-colorio",
    "href": "p03_Colordist.html#установка-модуля-colorio",
    "title": "3  Анализ цветовых щкал",
    "section": "3.1 Установка модуля colorio",
    "text": "3.1 Установка модуля colorio\nПерцептивная оценка цветовых градиентов требует вычислений в перцептивных цветовых пространствах. При этом стандартный класс QColor в QGIS ожидаемо поддерживает только общеупотребительные пространства RBG, CMYK, HSL и HSV:\n\n\n\nМетоды класса QColor для возврата значения цвета в виде массива цветовых компонент\n\n\nДля преобразования из этих пространств в перцептивные можно использовать библиотеку colorio . Чтобы ее установить в Python при QGIS введите в консоли Python следующие команды:\n\nimport pip\npip.main(['install', 'colorio'])\n\nПосле этого можно подключить требуемые библиотеки в начале скрипта:\n\nimport numpy as np\nimport colorio"
  },
  {
    "objectID": "p03_Colordist.html#извлечение-цветовой-шкалы",
    "href": "p03_Colordist.html#извлечение-цветовой-шкалы",
    "title": "3  Анализ цветовых щкал",
    "section": "3.2 Извлечение цветовой шкалы",
    "text": "3.2 Извлечение цветовой шкалы\nДля того чтобы выполнить анализ равномерности цветовой шкалы, необходимо получить цвета всех её классов. Для этого необходимо выполнить следующую последовательность действий:\n\nВыбрать активный слой (layer = iface.activeLayer()).\nПолучить его рендерер (renderer = layer.renderer()).\nПолучить список интервалов рендерера (ranges = renderer.ranges()).\nИзвлечь цвет для каждого интервала и наполнить этими цветами массив.\n\nЕсли известен список интервалов, то единичный можно получить просто по индексу. Печатается он довольно наглядно:\n&gt;&gt;&gt; ranges[0]\n&lt;QgsRendererRange: 0 - 364700 (0 - 364700)&gt;\nДоступ к цвету интервала можно получить через символ и его цвет:\n&gt;&gt;&gt; ranges[0].symbol().color()\n&lt;PyQt5.QtGui.QColor object at 0x194440dd0&gt;\nВ таком виде он, конечно, не очень удобен для последующего анализа. Поэтому можно воспользоваться одной из вышеприведенных функций для получения массива цветов:\n&gt;&gt;&gt; ranges[0].symbol().color().getRgb()\n(255, 255, 255, 255)\nМожно теперь объединить все эти операции в одну, получив массив цветовых массивов. Для удобства каждый цвет целесообразно преобразовать в массив numpy:\n\ncolors = [\n  np.array(r.symbol().color().getRgb())\n  for r in renderer.ranges()\n]\n\nИмея в распоряжении массив цветов, можно приступать к оценке качества цветовой шкалы."
  },
  {
    "objectID": "p03_Colordist.html#преобразование-цветовых-пространств",
    "href": "p03_Colordist.html#преобразование-цветовых-пространств",
    "title": "3  Анализ цветовых щкал",
    "section": "3.3 Преобразование цветовых пространств",
    "text": "3.3 Преобразование цветовых пространств\nЦветовые расстояния целесообразно рассчитывать в перцептивных цветовых пространствах. Для этих целей как правило используют CIE LAB. Следовательно, полученные цвета RGB необходимо в это пространство преобразовать. Для начала необходимо инициализировать эти цветовые пространства в colorio:\n\nsrgb = colorio.cs.SRGB255()\nslab = colorio.cs.CIELAB()\n\nПриставка 255 указывает, что цвета RGB будут задаваться в диапазоне от 0 до 255 — что соответствует стандартному формату, возвращаемому QColor.\nКак мы уже знаем, для преобразований между любыми цветовыми пространствами в качестве прокси используется пространство XYZ с виртуальными источниками освещения. Соответственно, любое цветовое пространство в colorio реализует 2 метода: to_xyz100() и from_xyz100() . Имея их, можно получить искомое преобразование на примере цвета [255, 217, 64] следующим образом:\n\nrgb = np.array([255, 217, 64])\nxyz = srgb.to_xyz100(rgb)\nlab = slab.from_xyz100(xyz)\n\nИли одним выражением:\n\nlab = slab.from_xyz100(srgb.to_xyz100(rgb))\n\nЧтобы сделать это преобразование для каждого элемента списка цветов можно использовать уже знакомый нам подход. При этом важно избавиться от 4-й компоненты цвета (прозрачности):\n\nlabs = [slab.from_xyz100(srgb.to_xyz100(color[0:3])) for color in colors]"
  },
  {
    "objectID": "p03_Colordist.html#вычисление-цветовых-расстояний",
    "href": "p03_Colordist.html#вычисление-цветовых-расстояний",
    "title": "3  Анализ цветовых щкал",
    "section": "3.4 Вычисление цветовых расстояний",
    "text": "3.4 Вычисление цветовых расстояний\nСуществует несколько распространенных методов вычисления цветовых расстояний (цветоразностей). Поскольку пространство CIE LAB является перцептивным, то предполагается, что изменения цвета в нем происходят линейно. Поэтому простейший подход CIE76 к вычислению цветоразностей в этом пространстве базируется на Евклидовом расстоянии:\n\\[\\Delta E^*_{ab} = \\sqrt{(\\Delta L^*)^2 + (\\Delta a^*)^2 + (\\Delta b^*)^2}\\] При этом значение \\(\\Delta E^*_{ab} \\approx 2.3\\) соответствует едва различимой цветоразности. Это означает, что цвета с такой разностью будет трудно дифференцировать (хотя, конечно, все еще зависит от условий наблюдения и размера цветового пятна). Существуют и более сложные формулы CIE94, CIE2000 и CMC, в которых вводятся дополнительные перцептивные корректировки.\nДля вычисления цветовых разностей используйте соответствующие функции:\n\ncolorio.diff.ciede76(lab1, lab2)\ncolorio.diff.ciede94(lab1, lab2)\ncolorio.diff.ciede2000(lab1, lab2)\ncolorio.diff.cmc(lab1, lab2)\n\nгде lab1 и lab2 — вектора numpy с цветами в пространстве CIE LAB.\nПрименительно к вектору таких цветов все расстояния между соседями можно вычислить в цикле:\n\nlabdist = []\nfor i in range(len(labs)-1):\n  labdist.append(colorio.diff.ciede76(lab[i], labs[i+1]))"
  },
  {
    "objectID": "p03_Colordist.html#анализ-цветовых-расстояний",
    "href": "p03_Colordist.html#анализ-цветовых-расстояний",
    "title": "3  Анализ цветовых щкал",
    "section": "3.5 Анализ цветовых расстояний",
    "text": "3.5 Анализ цветовых расстояний\nДля характеристики цветовых расстояний полезно посчитать их описательные статистики: среднее, стандартное отклонение, размах вариации. Для этого импортируем модуль statistics:\n\nimport statistics as st\n\nst.fmean(labdist)\nst.stdev(labdist)\nmin(labdist)\nmax(labdist)"
  },
  {
    "objectID": "p04_Rubberband.html#создание-косметического-слоя",
    "href": "p04_Rubberband.html#создание-косметического-слоя",
    "title": "4  Косметические слои",
    "section": "4.1 Создание косметического слоя",
    "text": "4.1 Создание косметического слоя\nКосметический слой может хранить только один объект — полигон, линию или точку. Для его создания используется функция QgsRubberBand(), которая принимает 2 параметра:\n\ncanvas — ссылка на текущий объект канвы карты (можно получить через iface.mapCanvas())\ngeometryType — тип геометрии слоя, может принимать значения QgsWkbTypes.LineGeometry, QgsWkbTypes.PolygonGeometry или QgsWkbTypes.PointGeometry.\n\nТаким образом, для создания полигонального косметического слоя необходима следующая последовательность действий:\n\ncanvas = iface.mapCanvas()\nlines = QgsRubberBand(canvas, QgsWkbTypes.LineGeometry)"
  },
  {
    "objectID": "p04_Rubberband.html#настройка-косметического-слоя",
    "href": "p04_Rubberband.html#настройка-косметического-слоя",
    "title": "4  Косметические слои",
    "section": "4.2 Настройка косметического слоя",
    "text": "4.2 Настройка косметического слоя\nВ процессе настройки косметический слой необходимо наполнить геометрией и задать символику. Для наполнения геометрией используйте метод класса setToGeometry(geom), где geom — это объект класса QgsGeometry. Аналогично для настройки цвета, размера, толщины, иконки и прочих параметров используются методы setColor(), setIconSize(), setWidth(), setIcon(). Например, при настройка линейного косметическеого слоя может выглядеть как:\n\nlines.setToGeometry(geom)\nlines.setColor(QColor(0,0,0))\nlines.setWidth(2)\n\n\nПолный список методов, который используется для настройки косметического слоя, доступен в документации API.\n\nЕсли вы работаете с точечным косметическом слоем и хотите отобразить множество точек, вам придется создать для каждой точки свой слой. Паттерн разработки в таком случае будет следующим:\n\npoints = []\nfor i in range(N):\n  pnt = QgsRubberBand(canvas, QgsWkbTypes.PointGeometry)\n  ... # настройка\n  points.append(pnt)\n\nЕсли точки будут отбражаться одинаковым символом, то задачу можно упростить, создав точечный слой, но подав при этом ему в качестве geom мультиточку:\n\npoints = QgsRubberBand(canvas, QgsWkbTypes.PointGeometry)\npoints.setGeometry(geom) # geom — мультиточка\n\n\n4.2.1 Создание геометрии\nКак было сказано выше, геометрия косметического слоя должна иметь класс QgsGeometry. Объекты этого класса создаются на основе геометрических примитивов разного типа. Для этого используются конструкторы:\n\n\n\nfromMultiPointXY\nCreates a new geometry from a QgsMultiPointXY object\n\n\n\n\nfromMultiPolygonXY\nCreates a new geometry from a QgsMultiPolygon\n\n\nfromMultiPolylineXY\nCreates a new geometry from a QgsMultiPolylineXY object\n\n\nfromPointXY\nCreates a new geometry from a QgsPointXY object\n\n\nfromPolygonXY\nCreates a new geometry from a QgsPolygon\n\n\nfromPolyline\nCreates a new LineString geometry from a list of QgsPoint points.\n\n\nfromPolylineXY\nCreates a new LineString geometry from a list of QgsPointXY points.\n\n\n\nСоответственно, чтобы создать точечный, линейный или полигональный объект, необходимо иметь в распоряжении объект QgsPointXY, либо список таких объектов. Вы можете соорудить такой объект вручную по координатам.\nТочку можно создать так:\n\nxy1 = QgsPointXY(10, 20) \nxy2 = QgsPointXY(15, 30)\nxy3 = QgsPointXY(-5, 15) \nxy4 = QgsPointXY(40, -2)\n\nДалее на основе этих точек можно создать, например, две точечных геометрии и одну линейную (отрезок):\n\npnt1 = QgsGeometry.fromPointXY(xy1)\npnt2 = QgsGeometry.fromPointXY(xy2)\npnt3 = QgsGeometry.fromPointXY(xy3)\npnt4 = QgsGeometry.fromPointXY(xy4)\n\nline12 = QgsGeometry.fromPolylineXY([xy1, xy2])\nline34 = QgsGeometry.fromPolylineXY([xy3, xy4])\n\nЕсли нужно в косметическом слое хранить множество точек или множество линий, можно сделать мультиточку или мультилинию, это вас избавит от необходимости создавать слой на каждый объект. Сделать это можно так:\n\nmpnt = QgsGeometry.fromMultiPointXY([xy1, xy2])\nmline = QgsGeometry.fromMultiLineXY([xy1, xy2], [xy3, xy4])\n\nПолученные объекты можно использовать в функции setGeometry() для назначения геометрии косметическому слою:\n\nlines.setToGeometry(mline)\npoints.setToGeometry(mline)"
  },
  {
    "objectID": "p04_Rubberband.html#удаление-косметического-слоя",
    "href": "p04_Rubberband.html#удаление-косметического-слоя",
    "title": "4  Косметические слои",
    "section": "4.3 Удаление косметического слоя",
    "text": "4.3 Удаление косметического слоя\nВажно уметь не только создавать, но также удалять косметические слои. По этой причине важно не просто создать слой, но и записать его в переменную, чтобы потом можно было обратиться к ней для удаления слоя.\nЕсли вы знаете, как называется переменная косметического слой, нужно сначала проверить, существует ли она, и если да — то удалить слой. Список существующих переменных можно получить через функцию locals(). Само же удаление делается посредством метода canvas.scene().removeItem(layer), где layer — ссылка на удаляемый косметический слой\nТаким образом, удаление созданного выше косметического слоя должно выполняться следующим образом:\n\nif ('links' in locals()):\n    canvas.scene().removeItem(links)\n\nАналогично будет для точек, но поскольку там может быть множество слоев, необходимо пройтись в цикле по списку для удаления каждого:\n\nif ('points' in locals()):\n    for p in points:\n        canvas.scene().removeItem(p)\n\nЕсли же вы исползуете мультиточечный слой, то удаление надо производить один раз:\n\nif ('points' in locals()):\n        canvas.scene().removeItem(points)"
  },
  {
    "objectID": "calibration.html",
    "href": "calibration.html",
    "title": "Appendix A — Калибровка монитора",
    "section": "",
    "text": "Калибровка монитора осуществляется для того, чтобы стандартизировать его цветопередачу. По результатам калибровки вы также получаете цветовой профиль, который сможете прикреплять к графическим файлам, создаваемым на вашем компьютере. Если такой файл будет открыт на другом мониторе, который также откалиброван, наличие двух цветовых профилей позволит графической системе путем преобразования цветовых компонент через промежуточное пространство XYZ отобразить файл в виде, максимально приближенном к тому, что вы видели на первом мониторе.\nДля калибровки используются колориметр и спектрометр. Основной прибор — это колоритметр, он измеряет характеристики излучения оттенков красного, синего и зеленого цвета и их комбинаций (включая градации серого от белого до черного). Спектрометр является вспомогательным прибором, который позволяет сделать коррекцию результатов колориметрических измерений путем более точных замеров характеристик излучения. В простейшем случае можно обойтись без спектрометра (но цветовой профиль получается менее точным).\nДля калибровки мы будем использовать программное обеспечение DisplayCAL и колориметр X-Rite i1 Display:\n\n\n\nПрограммное обеспечение для калибровки дисплея Display CAL\n\n\nНеобходимо загрузить DisplayCAL и установить его, а также подключить колориметр к порту USB.\nПри открытии программы необходимо выбрать ваш монитор и колоритметр в списках Дисплей и Инструмент. Поскольку спектрометра у нас нет, Коррекцию установите автоматическую:\n\n\n\nОсновное окно DisplayCAL\n\n\nЕсли колориметр отсутствует в списке инструментов, выберите в меню Инструменты пункт Обнаруженные устройства отображения и инструменты, чтобы произвести поиск заново:\n\n\n\nПринудительное обнаружение устройств\n\n\nПосле этого можно приступать к калибровке, если соблюдено следующее условие:\n\nВажно: перед началом калибровки монитор должен быть включён не менее 30 минут, а различные динамические настройки, повышающие чёткость изображения, ночной режим и прочее необходимо отключить.\n\nПосле того как монитор и колориметр определены, можно запускать калибровку, нажав для этого кнопку Калибровка и характеризация. Появится небольшое диалоговое окно, с помощью которого можно изменить положение и размеры области экрана, в пределах которой будут проводиться измерения:\n\n\n\nУстановка области калибровки\n\n\nВ центр этой области необходимо разместить колоритметр линзой в сторону экрана, а противовес свесить за экраном:\n\n\n\nУстановка колориметра\n\n\nПосле этого нужно нажать Начать измерения. В течение нескольких минут цветовые ползунки должны стабилизироваться в определенном положении:\n\n\n\nИсходное положение при калибровке\n\n\nДалее необходимо, меняя настройки монитора, привести ползунок яркости и ползунки трех цветовых компонент в центральное положение (или максимально близко к нему), что будет означать примерно сопоставимую интенсивность трех типов световых излучателей R,G,B.:\n\n\n\nПосле регулировки настроек монитора\n\n\nЕсли регулировки выполнены, можно нажать Продолжайте калибровку. В течение нескольких минут DisplayCAL будет показывать колориметру цветовые пятна разной яркости, насыщенности и цветового тона и выполнять измерения:\n\n\n\nКалибровка в процессе\n\n\nПосле калибровки будет запущен процесс создания цветового профиля и LUT (Look Up Table) для видеокарты:\n\n\n\nПроцесс создания цветового профиля\n\n\nЕсли профиль монитора успешно создан, то в конце процедуры вы увидите следующий диалог. Чтобы сразу же воспользоваться профилем, необходимо выбрать опцию Установить профиль:\n\n\n\nОкончание калибровки и параметры созданного профиля\n\n\nНазвание профиля и путь к нему можно посмотреть на вкладке Профилирование:\n\n\n\nПараметры созданного профиля\n\n\nЕсли вы пользуетесь операционной системой Windows, то получившися цветовой профиль должен быть активирован в настройках дисплея:\n\n\n\nАктивированный цветовой профиль в настройках дисплея.\n\n\nНа этом всё! 🤓"
  }
]