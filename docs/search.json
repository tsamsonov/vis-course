[
  {
    "objectID": "01_BasicAlgorithms.html#компьютерная-графика",
    "href": "01_BasicAlgorithms.html#компьютерная-графика",
    "title": "Основы компьютерной графики",
    "section": "Компьютерная графика",
    "text": "Компьютерная графика\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\nВизуальный аспект: компьютер → человек\nИнтерактивный аспект: человек → компьютер"
  },
  {
    "objectID": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "href": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "title": "Основы компьютерной графики",
    "section": "Связь с компьютерным зрением",
    "text": "Связь с компьютерным зрением\nКомпьютерная графика: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\nКомпьютерное зрение: определение параметров сцены и погруженных в нее объектов при заданных допущениях."
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер",
    "href": "01_BasicAlgorithms.html#графический-конвейер",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВ статичной сцене графический конвейер определяет последовательность отрисовки изображения."
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер-1",
    "href": "01_BasicAlgorithms.html#графический-конвейер-1",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВзаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения"
  },
  {
    "objectID": "01_BasicAlgorithms.html#структура-2d-приложения",
    "href": "01_BasicAlgorithms.html#структура-2d-приложения",
    "title": "Основы компьютерной графики",
    "section": "Структура 2D-приложения",
    "text": "Структура 2D-приложения\n\n\n\n\n\nГрафическая платформа отвечает за взаимодействие приложения и оборудования\nМодель приложения (application model) представляет визуализируемые данные\nКлиентская область (client area) определяет пространство, в котором приложение выполняет отрисовку.\nПорт просмотра (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели"
  },
  {
    "objectID": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "href": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "title": "Основы компьютерной графики",
    "section": "Эволюция графической платформы",
    "text": "Эволюция графической платформы\n1980-е — начало 1990-х (Apple QuickDraw, Microsoft GDI): отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка примитивов: геометрических форм или битмапов (пиксельных карт).\n\nКаждый примитив заполняется путем вызова определенной функции (например, FillRectangle).\nРазмер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.\n\nСередина 1990-х — н.вр. Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат."
  },
  {
    "objectID": "01_BasicAlgorithms.html#непосредственный-режим",
    "href": "01_BasicAlgorithms.html#непосредственный-режим",
    "title": "Основы компьютерной графики",
    "section": "Непосредственный режим",
    "text": "Непосредственный режим\nВ непосредственном режиме (immediate mode) клиент через графическую платформу обращается непосредственно к выводящему устройству.\n\nЗапись примитивов, переданных приложением, не выполняется.\nПри смене сцены приложение должно перерисовать ее целиком."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сохраненный-режим",
    "href": "01_BasicAlgorithms.html#сохраненный-режим",
    "title": "Основы компьютерной графики",
    "section": "Сохраненный режим",
    "text": "Сохраненный режим\nВ сохраненном режиме (retained mode) графическая платформа хранит спецификацию сцены в виде графа сцены (scene graph).\n\nОбъекты могут добавляться в граф сцены последовательно.\nКаждое изменение графа приводит к перерисовке сцены"
  },
  {
    "objectID": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "href": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "title": "Основы компьютерной графики",
    "section": "Процедурный и декларативный подходы",
    "text": "Процедурный и декларативный подходы\n\n\nПроцедурный код пишется на императивном языке программирования\n\nОписывает действия\nСтандарт при взаимодействии с графической платформой\nВ геоинформационных пакетах применяется на низком уровне, невидимом для пользователя\n\n\nДекларативные спецификации фиксируются на языке разметки\n\nОписывают результаты\nВспомогательное средство в графических платформах\nВ геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "href": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка векторных объектов",
    "text": "Отрисовка векторных объектов\n\nДве основных операции: обводка и заливка\nВ случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\nУстановить тип отображаемого объекта\nОрганизовать обход по всем уровням вложенности с помощью цикла\nНа самом низком уровне вложенности получить матрицу координат.\nПоследовательно соединяя соседние координаты в матрице, отрисовать границу отрезками."
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\nАлгоритм Брезенхема (Bresenham 1965)\ndraw_line(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nCистема экранных координат \\(ij\\), где \\(i\\) — строка (увеличивается сверху вниз), \\(j\\) — столбец (увеличивается слева направо),\n\n\\((i_0, j_0)\\) — начальная точка отрезка в экранных координатах\n\\((i_1, j_1)\\) — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: \\[\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}\\]\nВыразив \\(i\\), получаем: \\[i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\n\n\nСтандартно рассматривается отрисовка линии, которая располагается в секторе В-ЮВ, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 &lt; j_1,~i_0 \\leq i_1\\);\n\\(j_1 - j_0 \\geq i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора В-ЮВ алгоритм опирается на координаты \\(x\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{blue}{d = di / dj}\\);\n\\(\\color{blue}{i = i_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{blue}{j = j_0, ... j_1}\\), выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{blue}{i = i + \\texttt{sign}(di)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора В-СВ (только \\(i\\) будет уменьшаться).\nОбозначим случай draw_line_byJ(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\n\n\nАльтернативно рассматривается отрисовка линии, которая располагается в секторе Ю-ЮВ, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 \\leq j_1,~i_0 &lt; i_1\\);\n\\(j_1 - j_0 &lt; i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора Ю-ЮВ алгоритм опирается на координаты \\(i\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{red}{d = dj / di}\\);\n\\(\\color{red}{j = j_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{red}{i = i_0, ... i_1}\\) выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{red}{j = j + \\texttt{sign}(dj)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора Ю-ЮЗ (только \\(j\\) будет уменьшаться).\nОбозначим случай draw_line_byI(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на Python:\ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) &lt; abs(j1 - j0): # пологая линия\n        if j0 &gt; j1:\n            draw_line_byJ(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byJ(i0, j0, i1, j1, image, color)\n    else:\n        if i0 &gt; i1:                 # крутая линия\n            draw_line_byI(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byI(i0, j0, i1, j1, image, color)\nгде abs() — функция вычисления модуля."
  },
  {
    "objectID": "01_BasicAlgorithms.html#заливка-полигона",
    "href": "01_BasicAlgorithms.html#заливка-полигона",
    "title": "Основы компьютерной графики",
    "section": "Заливка полигона",
    "text": "Заливка полигона"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "href": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм сканирующей линии",
    "text": "Алгоритм сканирующей линии\nДля каждого \\(i_k = i_{min},...,i_{max}\\) получить упорядоченное по возрастанию множество \\(J = \\{j_0, j_1, ..., j_{n-1}\\}\\) столбцов пересечений с исходными линиями:\n\nДля каждой линии \\(l_m, m = 0,...,N-1\\):\n\n\nвычислить флаг пересечения \\(f: i^m_0 &gt; i_k \\neq i^m_1 &gt; i_k\\);\nесли \\(f = \\texttt{TRUE}\\), то\n\nвычислить \\(j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}\\);\nдобавить \\(j^m\\) в множество \\(J\\).\n\n\n\nЕсли \\(J\\) не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n\\[\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отсечение-отрезков",
    "href": "01_BasicAlgorithms.html#отсечение-отрезков",
    "title": "Основы компьютерной графики",
    "section": "Отсечение отрезков",
    "text": "Отсечение отрезков\nОдин из самых широко используемых — алгоритм Коэна-Сазерленда, в котором используется разбиение плоскости на 9 частей прямыми, координаты которых определяются границами прямоугольника (в частности — порта просмотра):\n\n\n\n\n\nINSIDE = 0 — \\(0000\\)\nLEFT = 1 — \\(0001\\)\nRIGHT = 2 — \\(0010\\)\nBOTTOM = 4 — \\(0100\\)\nTOP = 8 — \\(1000\\)\n\nОтрезки, обе точки которых находятся по одну сторону от прямоугольника, имеют совпадающий единичный бит в одной и той же позиции"
  },
  {
    "objectID": "01_BasicAlgorithms.html#вычисление-кодов-коэна-сазерленда",
    "href": "01_BasicAlgorithms.html#вычисление-кодов-коэна-сазерленда",
    "title": "Основы компьютерной графики",
    "section": "Вычисление кодов Коэна-Сазерленда",
    "text": "Вычисление кодов Коэна-Сазерленда\nПусть дана точка \\((i, j)\\), а также границы порта просмотра \\((i_{min}, i_{max})\\), \\((j_{min}, j_{max})\\).\nТогда код вычисляется следующим образом:\ndef code(i, j, imax, jmax):\n    code = INSIDE\n    if j &lt; jmin:\n        code |= LEFT\n    elif j &gt; jmax:\n        code |= RIGHT\n    if i &lt; imin:\n        code |= TOP\n    elif i &gt; imax:\n        code |= BOTTOM\n    return code\nВ данном случае применяется операция логическое ИЛИ, которая устанавливает в каждый бит \\(1\\), если хотя бы у одного из операндов соответствующий бит равен \\(1\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-коэна-сазерленда",
    "href": "01_BasicAlgorithms.html#алгоритм-коэна-сазерленда",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Коэна-Сазерленда",
    "text": "Алгоритм Коэна-Сазерленда\nДля каждого отрезка \\((i_0, j_0), (i_1, j_1)\\) выполняется бесконечный цикл, внутри которого ведутся следующие действия:\n\nВычисляются коды code0 и code1 для концов отрезка.\nЕсли оба конца находятся внутри порта просмотра (code0 | code1 == 0), то отрезок принимается целиком и цикл прерывается.\nЕсли оба конца находятся по одну сторону от порта просмотра (code0 & code1 != 0), то отрезок отклоняется целиком и цикл прерывается.\nВ противном случае (оба конца находятся по разные стороны от порта просмотра), выполняются следующие действия:\n\nВыбирается любая точка, находящаяся за пределами порта просмотра.\nВыполняется пересечение отрезка с прямой, определяющей ту сторону, в которой находится выбранная точка.\nВыбранная точка заменяется на найденное пересечение."
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nАффинное преобразование \\(f\\colon\\mathbb{R}^{n}\\to \\mathbb{R}^{n}\\) есть преобразование вида:\n\\[\nf(\\mathrm p) = \\mathbf M \\cdot \\mathrm p + \\mathrm v\n\\]\nгде \\(\\mathbf M\\) — обратимая матрица (квадратная матрица, определитель которой отличен от нуля) и \\(v\\in \\mathbb{R}^{n}\\).\n\\(\\mathbf M\\) и \\(\\mathrm v\\) обычно объединяются в одну матрицу \\(\\mathbf A\\), что требует представления \\(p\\) в однородных координатах: \\(\\widehat{\\mathrm p} = (x_p, y_p,..., 1)\\). В этом случае аффинное преобразование можно записать как:\n\\[\nf(\\mathrm p) = \\mathbf A \\cdot \\widehat{\\mathrm p} = \\left[ \\begin{array}{ccc|c} \\, & \\mathbf M & & \\mathrm v \\ \\\\ 0 & \\ldots & 0 & 1 \\end{array} \\right] \\begin{bmatrix} \\mathrm p \\\\ 1 \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования-1",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования-1",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nСдвиг на вектор трансляции \\(t = (t_x, t_y)\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} 1 &  0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf T(t_x, t_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1x + 0y + t_x1 \\\\ 0x + 1y + t_y1 \\\\ 0x + 0y + 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix},\n\\]\nПоворот на угол \\(\\theta\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 0 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} \\cos \\theta &  -\\sin \\theta & 0 \\\\ \\sin \\theta & \\cos \\theta  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf R(\\theta)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta \\\\ x \\sin \\theta + y \\cos \\theta \\\\ 1 \\end{bmatrix},\n\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#аффинные-преобразования-2",
    "href": "01_BasicAlgorithms.html#аффинные-преобразования-2",
    "title": "Основы компьютерной графики",
    "section": "Аффинные преобразования",
    "text": "Аффинные преобразования\nМасштабирование с коэффициентами \\(s_x, s_y\\):\n\\[\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} s_x &  0 & 0 \\\\ 0 & s_y  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf S(s_x, s_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x s_x \\\\ y s_y \\\\ 1 \\end{bmatrix},\n\\]\n\nпри навигации по карте \\(s_x = s_y = a\\)\nдля зеркального отражения по соответствующим осям \\(s_x\\) или \\(s_y\\) будут иметь отрицательные значения."
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\nПри загрузке слоя данных в пустой проект объекты вписываются в порт просмотра.\nПусть ограничивающий прямоугольник (экстент) данных имеет размеры \\([x_0, y_0]\\times[x_1, y_1]\\), а размер порта просмотра \\([0, di]\\times[0, dj]\\). Тогде необходимо выполнить следующие преобразования:\n\nСовместить начало координат с центром экстента данных — точкой \\([(x_1 + x_0)/2, (y_1 + y_0)/2]\\).\nНа оcнове сравнения пропорций экстента \\(\\frac{dy}{dx}\\) и порта просмотра \\(\\frac{di}{dj}\\) выбрать коэффициент масштабирования \\(s\\):\n\n\\[s = \\begin{cases}\n\\frac{dj}{dx},~\\texttt{если}~\\frac{dy}{dx} \\leq \\frac{di}{dj}\\\\\n\\frac{di}{dy},~\\texttt{если}~\\frac{dy}{dx} &gt; \\frac{di}{dj}\\\\\n\\end{cases}\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии-1",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии-1",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\n\nОтмасштабировать координаты на полученный коэффициент \\(s\\).\nПереместить отмасштабированное изображение в точку \\((di/2, dj/2)\\).\n\nИтоговая матрица преобразования \\(\\textbf{A}\\) будет выглядеть следующим образом:\n\\[\\textbf A = \\textbf T(di/2, dj/2)~\\textbf S(s)~\\textbf T(-(x_1 + x_0)/2, -(y_1 + y_0)/2)\\]\nТочки исходных объектов \\(p\\) будут трансформированы в точки внутри порта просмотра \\(p'\\) как:\n\\[p' = \\textbf A p\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#стандартные-сценарии-2",
    "href": "01_BasicAlgorithms.html#стандартные-сценарии-2",
    "title": "Основы компьютерной графики",
    "section": "Стандартные сценарии",
    "text": "Стандартные сценарии\nПусть текущая матрица отображения равна \\(A\\). Пользователь:\n\nперетащил изображение из точки \\((i_1, j_1)\\) в точку \\((i_2, j_2)\\):\n\n\\[\\mathbf A = \\mathbf T(i_2-i_1, j_2 - j_1)\\mathbf A\\]\n\nв точке \\((i, j)\\) прокрутил колесико мыши на \\(k &gt; 0\\) оборота:\n\n\\[\\mathbf A = \\mathbf T(i, j)~\\mathbf S(ks, ks)~\\mathbf T(-i, -j)~\\mathbf A\\]\n\nв точке \\((i, j)\\) прокрутил колесико мыши на \\(k &lt; 0\\) оборота:\n\n\\[\\mathbf A = \\mathbf T(i, j)~\\mathbf S(-\\frac{1}{ks}, -\\frac{1}{ks})~\\mathbf T(-i, -j)~\\mathbf A\\]\nКаждый оборот соответствует изменению масштаба в \\(s\\) раз."
  },
  {
    "objectID": "01_BasicAlgorithms.html#передискретизация-resampling",
    "href": "01_BasicAlgorithms.html#передискретизация-resampling",
    "title": "Основы компьютерной графики",
    "section": "Передискретизация (resampling)",
    "text": "Передискретизация (resampling)\nПередискретизация — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\nИсходное изображение"
  },
  {
    "objectID": "01_BasicAlgorithms.html#передискретизация-resampling-1",
    "href": "01_BasicAlgorithms.html#передискретизация-resampling-1",
    "title": "Основы компьютерной графики",
    "section": "Передискретизация (resampling)",
    "text": "Передискретизация (resampling)\nПередискретизация — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\nБлижайший сосед (укрупнение пикселя)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#передискретизация-resampling-2",
    "href": "01_BasicAlgorithms.html#передискретизация-resampling-2",
    "title": "Основы компьютерной графики",
    "section": "Передискретизация (resampling)",
    "text": "Передискретизация (resampling)\nПередискретизация — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\nБилинейная интерполяция (уменьшение пикселя)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#передискретизация-resampling-3",
    "href": "01_BasicAlgorithms.html#передискретизация-resampling-3",
    "title": "Основы компьютерной графики",
    "section": "Передискретизация (resampling)",
    "text": "Передискретизация (resampling)\nПередискретизация необходима при визуализации растрового изображения на растровом экране. Как правило, разрешение этих растров не совпадает."
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-ближайшего-соседа",
    "href": "01_BasicAlgorithms.html#метод-ближайшего-соседа",
    "title": "Основы компьютерной графики",
    "section": "Метод ближайшего соседа",
    "text": "Метод ближайшего соседа\nИспользуется значение ближайшего пикселя:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-билинейной-интерполяции",
    "href": "01_BasicAlgorithms.html#метод-билинейной-интерполяции",
    "title": "Основы компьютерной графики",
    "section": "Метод билинейной интерполяции",
    "text": "Метод билинейной интерполяции\nВосстанавливается поверхность в ячейке из 4 узлов:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-билинейной-интерполяции-1",
    "href": "01_BasicAlgorithms.html#метод-билинейной-интерполяции-1",
    "title": "Основы компьютерной графики",
    "section": "Метод билинейной интерполяции",
    "text": "Метод билинейной интерполяции\n\n\n\n\nКоэффициенты определяются по 4 точкам:\n\\[\\begin{cases}\na_{00} = f_{00},\\\\\na_{10} = f_{10} - f_{00},\\\\\na_{01} = f_{01} - f_{00},\\\\\na_{01} = f_{00} + f_{11} - f_{10} - f_{01}.\n\\end{cases}\\]\n\\[f(x, y) = a_{00} + a_{10}x + a_{01}y + a_{11}xy\\]\nКоординаты \\(x\\) и \\(y\\) меняются в диапазоне от \\(0\\) до \\(1\\) в пределах ячейки."
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-бикубической-интерполяции",
    "href": "01_BasicAlgorithms.html#метод-бикубической-интерполяции",
    "title": "Основы компьютерной графики",
    "section": "Метод бикубической интерполяции",
    "text": "Метод бикубической интерполяции\nВосстанавливается поверхность в 9 ячейках, окружающих узел:"
  },
  {
    "objectID": "01_BasicAlgorithms.html#метод-бикубической-интерполяции-1",
    "href": "01_BasicAlgorithms.html#метод-бикубической-интерполяции-1",
    "title": "Основы компьютерной графики",
    "section": "Метод бикубической интерполяции",
    "text": "Метод бикубической интерполяции\n\n\n\n\nКоэффициенты определяются по 16 точкам:\n\\[\\begin{cases}\nf(0,0) = a_{00},\\\\\nf(1,0) = a_{00} + a_{10} + a_{20} + a_{30},\\\\\nf(0,1) = a_{00} + a_{01} + a_{02} + a_{03},\\\\\nf(1,1) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij},\\\\\n\\dots\n\\end{cases}\\]\n\\[f(x, y) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij} x^i y^j\\]\nКоординаты \\(x\\) и \\(y\\) меняются в диапазоне от \\(0\\) до \\(1\\) в пределах окрестности \\(3 \\times 3\\) ячеек."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сглаживание-antialiasing",
    "href": "01_BasicAlgorithms.html#сглаживание-antialiasing",
    "title": "Основы компьютерной графики",
    "section": "Сглаживание (antialiasing)",
    "text": "Сглаживание (antialiasing)\nПри крупном размере пиксела выводящего устройства ступенчатость линий и границ полигонов становится заметной.\nДля устранения эффекта ступенчатости используется сглаживание (antialiasing)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сглаживание-antialiasing-1",
    "href": "01_BasicAlgorithms.html#сглаживание-antialiasing-1",
    "title": "Основы компьютерной графики",
    "section": "Сглаживание (antialiasing)",
    "text": "Сглаживание (antialiasing)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#суперсемплинг-antialiasing",
    "href": "01_BasicAlgorithms.html#суперсемплинг-antialiasing",
    "title": "Основы компьютерной графики",
    "section": "Суперсемплинг (antialiasing)",
    "text": "Суперсемплинг (antialiasing)\nПусть результирующее растровое изображение \\(R\\) имеет размеры \\(m \\times n\\).\n\nСоздается буферное изображение \\(R_b\\) размером \\(km \\times kn\\), где \\(k \\in \\mathbb{N^*}\\) — коэффициент сглаживания (положительное натуральное число).\nОбъекты отрисовываются в \\(R_b\\).\nПроизводится передискретизация \\(R_b \\to R\\) с использованием блочной фильтрации (box filter). Значение результирующего пиксела \\(R[i, j]\\) равняется среднему арифметическому значений \\(R_b\\), попадающих в его пределы:\n\n\\[R[i, j] = \\sum_{l = 1}^L s(R_b) / L,\\]\nгде \\(s(R_b)\\) — выборочное значение (сэмпл), взятое с \\(R_b\\), \\(L\\) — количество сэмплов"
  },
  {
    "objectID": "01_BasicAlgorithms.html#суперсемплинг-antialiasing-1",
    "href": "01_BasicAlgorithms.html#суперсемплинг-antialiasing-1",
    "title": "Основы компьютерной графики",
    "section": "Суперсемплинг (antialiasing)",
    "text": "Суперсемплинг (antialiasing)\n\n\nБез сглаживания\n\n\n\n\n\n\nСо сглаживанием"
  },
  {
    "objectID": "01_BasicAlgorithms.html#библиография",
    "href": "01_BasicAlgorithms.html#библиография",
    "title": "Основы компьютерной графики",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций\n\n\n\n\nBresenham, J. E. 1965. «Algorithm for Computer Control of a Digital Plotter». IBM Systems Journal 4 (1): 25–30. https://doi.org/10.1147/sj.41.0025."
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-объектов",
    "href": "01_BasicAlgorithms.html#отрисовка-объектов",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка объектов",
    "text": "Отрисовка объектов\n\nВыполняется после отсечения\nДве основных операции: обводка и заливка\nВ случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\nУстановить тип отображаемого объекта\nОрганизовать обход по всем уровням вложенности с помощью цикла\nНа самом низком уровне вложенности получить матрицу координат.\nПоследовательно соединяя соседние координаты в матрице, отрисовать границу отрезками."
  },
  {
    "objectID": "02_Classifications.html#эмпирическая-функция-распределения",
    "href": "02_Classifications.html#эмпирическая-функция-распределения",
    "title": "Классификация одномерных рядов",
    "section": "Эмпирическая функция распределения",
    "text": "Эмпирическая функция распределения\nФункция распределения \\(F(x) = P(X &lt; x)\\) является одной из основных характеристик одномерного ряда данных.\nВ практической работе строится выборочная (эмпирическая) ФР."
  },
  {
    "objectID": "02_Classifications.html#библиография",
    "href": "02_Classifications.html#библиография",
    "title": "Классификация одномерных рядов",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций"
  },
  {
    "objectID": "02_Classifications.html#функция-распределения",
    "href": "02_Classifications.html#функция-распределения",
    "title": "Классификация одномерных рядов",
    "section": "Функция распределения",
    "text": "Функция распределения\nФункция распределения \\(F(x) = P(X &lt; x)\\) является одной из основных характеристик случайной величины.\nВ практической работе используется выборочная ФР \\(\\widehat F(x)\\)."
  },
  {
    "objectID": "02_Classifications.html#выборочная-функция-распределения",
    "href": "02_Classifications.html#выборочная-функция-распределения",
    "title": "Классификация одномерных рядов",
    "section": "Выборочная функция распределения",
    "text": "Выборочная функция распределения\nВыборочная функция распределения \\(\\widehat F(x)\\) определяется следующим образом:\n\\[\n\\widehat F(x) = \\frac{1}{n}\\sum_{i=1}^n \\theta(x-X_i),\n\\]\nгде \\(\\theta(x)\\) — функция Хевисайда:\n\\[\n\\theta(x)=\\begin{cases} 0, & x&lt;0;\n\\\\ 1, & x\\geqslant 0.\\end{cases}\n\\]\nПри \\(n \\rightarrow \\infty\\) функция \\(\\widehat F(x)\\) равномерно сходится к \\(F(x)\\) (теорема Колмогорова).\n\n\n\n\n\n\nПроще говоря\n\n\nЧем больше выборка, тем точнее выборочная ФР описывает реальную."
  },
  {
    "objectID": "02_Classifications.html#равные-интервалы",
    "href": "02_Classifications.html#равные-интервалы",
    "title": "Классификация одномерных рядов",
    "section": "Равные интервалы",
    "text": "Равные интервалы\nРазмер класса равен \\([\\max(X) - \\min(X)] / k\\), где \\(k\\) — число классов."
  },
  {
    "objectID": "02_Classifications.html#нормальное-распределение",
    "href": "02_Classifications.html#нормальное-распределение",
    "title": "Классификация одномерных рядов",
    "section": "Нормальное распределение",
    "text": "Нормальное распределение\n\\[\n\\Phi(x) = \\frac 1 {\\sqrt{2\\pi}} \\int\\limits_{-\\infty}^{x} e^{-t^2/2} \\, dt.\n\\]"
  },
  {
    "objectID": "02_Classifications.html#логнормальное-распределение",
    "href": "02_Classifications.html#логнормальное-распределение",
    "title": "Классификация одномерных рядов",
    "section": "Логнормальное распределение",
    "text": "Логнормальное распределение\n\\[\nF(x) = \\Phi\\left( \\frac{(\\ln x) - \\mu} \\sigma \\right)\n\\]"
  },
  {
    "objectID": "02_Classifications.html#экспоненциальное-распределение",
    "href": "02_Classifications.html#экспоненциальное-распределение",
    "title": "Классификация одномерных рядов",
    "section": "Экспоненциальное распределение",
    "text": "Экспоненциальное распределение\n\\[\nF(x) = \\left\\{\\begin{matrix}\n1-e^{-\\lambda x}&,\\; x \\ge 0, \\\\\n0 &,\\; x &lt; 0.\n\\end{matrix}\\right.\n\\]"
  },
  {
    "objectID": "02_Classifications.html#квантили",
    "href": "02_Classifications.html#квантили",
    "title": "Классификация одномерных рядов",
    "section": "Квантили",
    "text": "Квантили\nКоличество элементов в каждом классе \\(c \\approx n/k\\)."
  },
  {
    "objectID": "02_Classifications.html#стандартные-отклонения",
    "href": "02_Classifications.html#стандартные-отклонения",
    "title": "Классификация одномерных рядов",
    "section": "Стандартные отклонения",
    "text": "Стандартные отклонения\nГраницы классов определяются значениями \\(\\overline X \\pm \\alpha S\\), где \\(\\alpha = 1, 2, ..., (k+1)/2\\)\n\n\n\n\n\n\n\n\n\n\nМетод подходит только для данных с нормальным распределением."
  },
  {
    "objectID": "02_Classifications.html#метод-дженкса-кэспалла-1971",
    "href": "02_Classifications.html#метод-дженкса-кэспалла-1971",
    "title": "Классификация одномерных рядов",
    "section": "Метод Дженкса-Кэспалла (1971)",
    "text": "Метод Дженкса-Кэспалла (1971)\nГраницы классов определяются путем минимизации суммы расстояний от элементов классов до их медиан (ADCM — absolute deviation about class median):\n\\[\nADCM = \\sum_{j=1}^k \\sum_{i=1}^{n_k} |X_{ij} - \\operatorname{med}(X_j)|\n\\]\nМетод базируется на итеративном алгоритме:\n\nКлассифицировать выборку методом квантилей на \\(k\\) классов.\nВычислить для каждого элемента его отклонение от медианы собственного и соседних классов.\nПока есть элементы, располагающиеся ближе к соседней медиане, чем к своей:\n\nПереместить элемент в ближайший соседний класс\nОбновить значения медиан и расстояний для изменившихся классов и их соседей"
  },
  {
    "objectID": "02_Classifications.html#метод-дженкса-кэспалла-1971-1",
    "href": "02_Classifications.html#метод-дженкса-кэспалла-1971-1",
    "title": "Классификация одномерных рядов",
    "section": "Метод Дженкса-Кэспалла (1971)",
    "text": "Метод Дженкса-Кэспалла (1971)\nГраницы классов определяются путем минимизации ADCM"
  },
  {
    "objectID": "02_Classifications.html#метод-фишера-дженкса-1958-1977",
    "href": "02_Classifications.html#метод-фишера-дженкса-1958-1977",
    "title": "Классификация одномерных рядов",
    "section": "Метод Фишера-Дженкса (1958, 1977)",
    "text": "Метод Фишера-Дженкса (1958, 1977)\nТак же как и метод Дженкса-Кэспалла, минимизирует ADCM, однако использует рекурсивную, а не итеративную процедуру. В основе лежит теорема:\n\nКаждое оптимальное разбиение множества есть объединение оптимальных разбиение его подмножеств\n\nТогда границей \\(j\\) оптимального разбиения \\(X\\) на 2 класса будем считать\n\\[\n\\operatorname{argmin}_j \\big[D(1, j) + D(j+1, n)\\big],\\\\D(a, b) = \\sum_{i = a}^b |X_i - \\operatorname{med}(X_{[a,b]})|\n\\]\nЕсли число классов \\(k &gt; 2\\), то выбирается тот из них, у которого максимальное значение \\(D\\) и аналогичным образом разбивается на \\(2\\) класса."
  },
  {
    "objectID": "02_Classifications.html#метод-фишера-дженкса-1958-1977-1",
    "href": "02_Classifications.html#метод-фишера-дженкса-1958-1977-1",
    "title": "Классификация одномерных рядов",
    "section": "Метод Фишера-Дженкса (1958, 1977)",
    "text": "Метод Фишера-Дженкса (1958, 1977)\nДанный метод также известен автоматизированный вариант классификации методом Natural Breaks"
  },
  {
    "objectID": "02_Classifications.html#метод-headtail-jiang-2013",
    "href": "02_Classifications.html#метод-headtail-jiang-2013",
    "title": "Классификация одномерных рядов",
    "section": "Метод Head/Tail (Jiang, 2013)",
    "text": "Метод Head/Tail (Jiang, 2013)\nВ данном методе используется рекурсивное разбиение выборки средним значением.\n\nРазбить выборку на \\(2\\) класса, используя среднее значение\nПовторять процедуру для класса выше среднего, до тех пор пока не будет достигнуто\n\nтребуемое число классов или\nдоля значений выше среднего не превысит \\(40\\%\\)\n\n\nПороговый критерий в \\(40\\%\\) является экспертным (предложен автором метода) и может быть модифицирован.\n\nМетод годится для распределений с “тяжелым хвостом”, т.е. подчиняющихся экспоненциальному закону."
  },
  {
    "objectID": "02_Classifications.html#стандартные-отклонения-1",
    "href": "02_Classifications.html#стандартные-отклонения-1",
    "title": "Классификация одномерных рядов",
    "section": "Стандартные отклонения",
    "text": "Стандартные отклонения\nДанный метод не подходит для распределений, отличающихся от нормального. Например, для экспоненциального:\n\n\n\n\n\n\n\n\n\n\nМетод подходит только для данных с нормальным распределением."
  },
  {
    "objectID": "02_Classifications.html#метод-фишера-дженкса-1958-1977-2",
    "href": "02_Classifications.html#метод-фишера-дженкса-1958-1977-2",
    "title": "Классификация одномерных рядов",
    "section": "Метод Фишера-Дженкса (1958, 1977)",
    "text": "Метод Фишера-Дженкса (1958, 1977)\nДанный метод плохо работает с нормальным распределением:"
  },
  {
    "objectID": "02_Classifications.html#метод-фишера-дженкса-1958-1977-3",
    "href": "02_Classifications.html#метод-фишера-дженкса-1958-1977-3",
    "title": "Классификация одномерных рядов",
    "section": "Метод Фишера-Дженкса (1958, 1977)",
    "text": "Метод Фишера-Дженкса (1958, 1977)\nНо хорошо справляется с экспоненциальным:"
  },
  {
    "objectID": "02_Classifications.html#метод-headtail-jiang-2013-1",
    "href": "02_Classifications.html#метод-headtail-jiang-2013-1",
    "title": "Классификация одномерных рядов",
    "section": "Метод Head/Tail (Jiang, 2013)",
    "text": "Метод Head/Tail (Jiang, 2013)\nДанный метод плохо работает с нормальным распределением:"
  },
  {
    "objectID": "02_Classifications.html#метод-headtail-jiang-2013-2",
    "href": "02_Classifications.html#метод-headtail-jiang-2013-2",
    "title": "Классификация одномерных рядов",
    "section": "Метод Head/Tail (Jiang, 2013)",
    "text": "Метод Head/Tail (Jiang, 2013)\nНо хорошо справляется с экспоненциальным:"
  },
  {
    "objectID": "02_Classifications.html#gadf",
    "href": "02_Classifications.html#gadf",
    "title": "Классификация одномерных рядов",
    "section": "GADF",
    "text": "GADF\nGADF (Goodness of Absolute Deviation Fit) — метрика, характеризующая эффективность классификации:\n\\[\nGADF = 1 - \\frac{\\sum_{j=1}^k \\sum_{i=1}^{n_k} |X_{ij} - \\operatorname{med}(X_j)|}{\\sum_{i=1}^{n} |X_{i} - \\operatorname{med}(X)|}\n\\]\nGADF показывает как отклонения внутри классов соотносятся с отклонениями всей выборки. Чем\n\n\n\n\n\n\nПрименение\n\n\nМетрику GADF можно использовать для того чтобы определить оптимальный метод классификации"
  },
  {
    "objectID": "02_Classifications.html#gadf-1",
    "href": "02_Classifications.html#gadf-1",
    "title": "Классификация одномерных рядов",
    "section": "GADF",
    "text": "GADF\nGADF для нормального распределения:"
  },
  {
    "objectID": "02_Classifications.html#gadf-2",
    "href": "02_Classifications.html#gadf-2",
    "title": "Классификация одномерных рядов",
    "section": "GADF",
    "text": "GADF\nGADF для экспоненциального распределения:"
  },
  {
    "objectID": "02_Classifications.html#полезные-функции",
    "href": "02_Classifications.html#полезные-функции",
    "title": "Классификация одномерных рядов",
    "section": "Полезные функции",
    "text": "Полезные функции\n\n\n\n\n\n\n\nФункция\nНазначение\n\n\n\n\nx = np.random.exponential()\nгенерация экспоненциальной выборки\n\n\nx = np.random.normal()\nгенерация нормальной выборки\n\n\nx = np.random.lognormal()\nгенерация логнормальной выборки\n\n\nmatplotlib.pyplot.ecdf(x)\nвизуализация выборочной ФР\n\n\nclasses = mapclassify.&lt;method&gt;(x)\nклассификация методами mapclassify\n\n\nbreaks = classes.bins\nизвлечение границ классов\n\n\ngadf = classes.get_gadf()\nизвлечение GADF\n\n\nplt.vlines(breaks)\nвизуализация линий классов на графике \\(F(x)\\)\n\n\nfor brk in breaks:\nplt.text(brk,...)\nвизуализация значений границ классов на графике \\(F(x)\\)"
  },
  {
    "objectID": "03_Choropleths.html#картограммы",
    "href": "03_Choropleths.html#картограммы",
    "title": "Картограммы",
    "section": "Картограммы",
    "text": "Картограммы\nПри использовании картограмм для визуализации пространственных данных необходимо учитывать следующие аспекты:\n\nСтандартизация данных\nРазличия в цветовых шкалах и критерии их выбора\nИспользование методов классификации или непрерывных шкал\nОформление легенды\nОценка визуальной сложности\nТехнические возможности программных библиотек"
  },
  {
    "objectID": "03_Choropleths.html#стандартизация",
    "href": "03_Choropleths.html#стандартизация",
    "title": "Картограммы",
    "section": "Стандартизация",
    "text": "Стандартизация\nПоскольку единицы картографирования имеют разный размер, необходимо выполнять стандартизацию данных — нормировку сумм и площадей.\nПри стандартизации используются отношения:\n\nПлощадь на площадь\nСумма на площадь\nСумма на сумму\n\n\n\n\n\n\n\nСумма и площадь\n\n\nПод суммой в данном случае понимается показатель, не являющийся площадью. Например, объем заготавливаемой древесины. Ему можно противопоставить площадь лесов.\n\n\n\n\n\n\n\n\n\nСтандартизация без площадей\n\n\nПри делении суммы на сумму косвенным образом учитывается и неравенство площадей, т.к. более крупные площади часто имеют и более крупные суммы показателей."
  },
  {
    "objectID": "03_Choropleths.html#библиография",
    "href": "03_Choropleths.html#библиография",
    "title": "Картограммы",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций"
  },
  {
    "objectID": "03_Choropleths.html#стандартизация-1",
    "href": "03_Choropleths.html#стандартизация-1",
    "title": "Картограммы",
    "section": "Стандартизация",
    "text": "Стандартизация\nПример: доля возделываемых площадей, с которых собирается урожай (А) и урожайность с единицы площади (В)\n\nОт типа стандартизации зависит пространственное распределение показателя"
  },
  {
    "objectID": "03_Choropleths.html#цветовые-шкалы",
    "href": "03_Choropleths.html#цветовые-шкалы",
    "title": "Картограммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nПоследовательные шкалы используются для отображения униполярных показателей (не имеющих нейтральное значение).\n\n\nОдноцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nМногоцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВ последовательных шкалах понижается светлота и увеличивается насыщенность."
  },
  {
    "objectID": "03_Choropleths.html#цветовые-шкалы-1",
    "href": "03_Choropleths.html#цветовые-шкалы-1",
    "title": "Картограммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nРасходящиеся шкалы используются для отображения биполярных показателей (имеющих нейтральное значение, обычно \\(0\\)).\n\n\nДвухцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТрехцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nРасходящиеся шкалы получаются путем объединения двух последовательных шкал"
  },
  {
    "objectID": "03_Choropleths.html#цветовые-шкалы-2",
    "href": "03_Choropleths.html#цветовые-шкалы-2",
    "title": "Картограммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nКатегориальные шкалы используются для отображения номинальных (качественных) показателей.\n\n\nНасыщенные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПастельные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nДля категориальных шкал важна одинаковая светлота и насыщенность элементов.\n\n\n\n\n\n\nНоминальные данные\n\n\nНоминальные данные нельзя картографировать с помощью последовательных и расходящихся шкал"
  },
  {
    "objectID": "03_Choropleths.html#color-brewer",
    "href": "03_Choropleths.html#color-brewer",
    "title": "Картограммы",
    "section": "Color Brewer",
    "text": "Color Brewer\nДля выбора шкал удобно использовать сайт Color Brewer. Его шкалы есть в matplotlib и seaborn."
  },
  {
    "objectID": "03_Choropleths.html#классификация-или-нет",
    "href": "03_Choropleths.html#классификация-или-нет",
    "title": "Картограммы",
    "section": "Классификация или нет?",
    "text": "Классификация или нет?\nНеклассифицированные картограммы точнее отображают данные, однако могут быть трудны для восприятия в зависимости от распределения показателя."
  },
  {
    "objectID": "03_Choropleths.html#классификация-или-нет-1",
    "href": "03_Choropleths.html#классификация-или-нет-1",
    "title": "Картограммы",
    "section": "Классификация или нет?",
    "text": "Классификация или нет?\nНеклассифицированные картограммы точнее отображают данные, однако могут быть трудны для восприятия в зависимости от распределения показателя."
  },
  {
    "objectID": "03_Choropleths.html#легенда",
    "href": "03_Choropleths.html#легенда",
    "title": "Картограммы",
    "section": "Легенда",
    "text": "Легенда\n\n\nВ американской картографической школе принято плашки для легенды картограмм показывать слитно, т.к. это указывает на соседство учетных единиц\n\nДопускается указание границ вместо интервалов\n\nВ русской школе плашки для легенды картограмм принято показывать раздельно, т.к. учетные единицы могут не быть в соседних классах"
  },
  {
    "objectID": "03_Choropleths.html#легенда-1",
    "href": "03_Choropleths.html#легенда-1",
    "title": "Картограммы",
    "section": "Легенда",
    "text": "Легенда\n\n\nЭлементы упорядочиваются последовательно, при этом предпочтительным вариантом является увеличение слева направо (A) и снизу вверх (C).\nДругие варианты допустимы, но менее ассоциативны (читаем слева направо, выше — больше).\n\n\n\n\n\n\nКоличество классов\n\n\nЧитатель карты нормально различает 5, в некоторых случаях до 7 классов. Больше делать не рекомендуется."
  },
  {
    "objectID": "03_Choropleths.html#визуальная-сложность",
    "href": "03_Choropleths.html#визуальная-сложность",
    "title": "Картограммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nСложность: визуальная загруженность, мозаичность изображения\n\\[C = \\frac{N_{c}}{N},\\]\nгде \\(N\\) — общее число полигонов/границ/вершин в полном наборе единиц, \\(N_c\\) — число тех же элементов после объединения единиц, попадающих в один класс.\n\n\n\n\n\n\nИнтерпретация\n\n\nСложность картограмм показывает на какое количество однородных областей делится изображение при выбранном методе классификации и количестве классов.\n\n\n\n\n\n\n\n\n\nПрименение\n\n\nНаилучшие картограммы получаются при оптимальном сочетании добротности классификации (GADF) и визуальной сложности (C)."
  },
  {
    "objectID": "03_Choropleths.html#визуальная-сложность-1",
    "href": "03_Choropleths.html#визуальная-сложность-1",
    "title": "Картограммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nВ зависимости от выбранного метода классификации и количества классов будет меняться характер распределения и его визуальная сложность.\n\nФишер-Дженкс (k = 8, C = 0.47)"
  },
  {
    "objectID": "03_Choropleths.html#визуальная-сложность-2",
    "href": "03_Choropleths.html#визуальная-сложность-2",
    "title": "Картограммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nВ зависимости от выбранного метода классификации и количества классов будет меняться характер распределения и его визуальная сложность.\n\nКвантили (k = 4, C = 0.31)"
  },
  {
    "objectID": "04_Diagrams.html#картодиаграммы",
    "href": "04_Diagrams.html#картодиаграммы",
    "title": "Значки и картодиаграммы",
    "section": "Картодиаграммы",
    "text": "Картодиаграммы"
  },
  {
    "objectID": "04_Diagrams.html#значки-и-картодиаграммы",
    "href": "04_Diagrams.html#значки-и-картодиаграммы",
    "title": "Значки и картодиаграммы",
    "section": "Значки и картодиаграммы",
    "text": "Значки и картодиаграммы"
  },
  {
    "objectID": "04_Diagrams.html#вычисление-размера",
    "href": "04_Diagrams.html#вычисление-размера",
    "title": "Значки и картодиаграммы",
    "section": "Вычисление размера",
    "text": "Вычисление размера\n\n\n\n\nВ отличие от картограмм для порпорциональных символов редко используется классификация, т.к. легко оценить размеры.\n\nЗадается площадь символа \\(S_{min}\\), соответствующая минимальному значению показателя \\(V_{min}\\)\nПлощадь символа для произвольного значения \\(V\\) будет равна:\n\\[\nS = S_{min} \\frac{V}{V_{min}}\n\\]\nОднако шкала может быть и относительной, если задается максимальный размер диаграммы \\(S_{max}\\):\n\\[\nS = S_{min} + (S_{max} - S_{min}) \\frac{V - V_{min}}{V_{max} - V_{min}}\n\\]"
  },
  {
    "objectID": "04_Diagrams.html#стандартизация",
    "href": "04_Diagrams.html#стандартизация",
    "title": "Значки и картодиаграммы",
    "section": "Стандартизация",
    "text": "Стандартизация\nПоскольку единицы картографирования имеют разный размер, необходимо выполнять стандартизацию данных — нормировку сумм и площадей.\nПри стандартизации используются отношения:\n\nПлощадь на площадь\nСумма на площадь\nСумма на сумму\n\n\n\n\n\n\n\nСумма и площадь\n\n\nПод суммой в данном случае понимается показатель, не являющийся площадью. Например, объем заготавливаемой древесины. Ему можно противопоставить площадь лесов.\n\n\n\n\n\n\n\n\n\nСтандартизация без площадей\n\n\nПри делении суммы на сумму косвенным образом учитывается и неравенство площадей, т.к. более крупные площади часто имеют и более крупные суммы показателей."
  },
  {
    "objectID": "04_Diagrams.html#стандартизация-1",
    "href": "04_Diagrams.html#стандартизация-1",
    "title": "Значки и картодиаграммы",
    "section": "Стандартизация",
    "text": "Стандартизация\nПример: доля возделываемых площадей, с которых собирается урожай (А) и урожайность с единицы площади (В)\n\nОт типа стандартизации зависит пространственное распределение показателя"
  },
  {
    "objectID": "04_Diagrams.html#цветовые-шкалы",
    "href": "04_Diagrams.html#цветовые-шкалы",
    "title": "Значки и картодиаграммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nПоследовательные шкалы используются для отображения униполярных показателей (не имеющих нейтральное значение).\n\n\nОдноцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nМногоцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВ последовательных шкалах понижается светлота и увеличивается насыщенность."
  },
  {
    "objectID": "04_Diagrams.html#цветовые-шкалы-1",
    "href": "04_Diagrams.html#цветовые-шкалы-1",
    "title": "Значки и картодиаграммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nРасходящиеся шкалы используются для отображения биполярных показателей (имеющих нейтральное значение, обычно \\(0\\)).\n\n\nДвухцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТрехцветные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nРасходящиеся шкалы получаются путем объединения двух последовательных шкал"
  },
  {
    "objectID": "04_Diagrams.html#цветовые-шкалы-2",
    "href": "04_Diagrams.html#цветовые-шкалы-2",
    "title": "Значки и картодиаграммы",
    "section": "Цветовые шкалы",
    "text": "Цветовые шкалы\nКатегориальные шкалы используются для отображения номинальных (качественных) показателей.\n\n\nНасыщенные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПастельные\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nДля категориальных шкал важна одинаковая светлота и насыщенность элементов.\n\n\n\n\n\n\nНоминальные данные\n\n\nНоминальные данные нельзя картографировать с помощью последовательных и расходящихся шкал"
  },
  {
    "objectID": "04_Diagrams.html#color-brewer",
    "href": "04_Diagrams.html#color-brewer",
    "title": "Значки и картодиаграммы",
    "section": "Color Brewer",
    "text": "Color Brewer\nДля выбора шкал удобно использовать сайт Color Brewer. Его шкалы есть в matplotlib и seaborn."
  },
  {
    "objectID": "04_Diagrams.html#классификация-или-нет",
    "href": "04_Diagrams.html#классификация-или-нет",
    "title": "Значки и картодиаграммы",
    "section": "Классификация или нет?",
    "text": "Классификация или нет?\nНеклассифицированные картограммы точнее отображают данные, однако могут быть трудны для восприятия в зависимости от распределения показателя."
  },
  {
    "objectID": "04_Diagrams.html#классификация-или-нет-1",
    "href": "04_Diagrams.html#классификация-или-нет-1",
    "title": "Значки и картодиаграммы",
    "section": "Классификация или нет?",
    "text": "Классификация или нет?\nНеклассифицированные картограммы точнее отображают данные, однако могут быть трудны для восприятия в зависимости от распределения показателя."
  },
  {
    "objectID": "04_Diagrams.html#легенда",
    "href": "04_Diagrams.html#легенда",
    "title": "Значки и картодиаграммы",
    "section": "Легенда",
    "text": "Легенда\n\n\nВ американской картографической школе принято плашки для легенды картограмм показывать слитно, т.к. это указывает на соседство учетных единиц\n\nДопускается указание границ вместо интервалов\n\nВ русской школе плашки для легенды картограмм принято показывать раздельно, т.к. учетные единицы могут не быть в соседних классах"
  },
  {
    "objectID": "04_Diagrams.html#легенда-1",
    "href": "04_Diagrams.html#легенда-1",
    "title": "Значки и картодиаграммы",
    "section": "Легенда",
    "text": "Легенда\n\n\nЭлементы упорядочиваются последовательно, при этом предпочтительным вариантом является увеличение слева направо (A) и снизу вверх (C).\nДругие варианты допустимы, но менее ассоциативны (читаем слева направо, выше — больше).\n\n\n\n\n\n\nКоличество классов\n\n\nЧитатель карты нормально различает 5, в некоторых случаях до 7 классов. Больше делать не рекомендуется."
  },
  {
    "objectID": "04_Diagrams.html#визуальная-сложность",
    "href": "04_Diagrams.html#визуальная-сложность",
    "title": "Значки и картодиаграммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nСложность: визуальная загруженность, мозаичность изображения\n\\[C = \\frac{N_{c}}{N},\\]\nгде \\(N\\) — общее число полигонов/границ/вершин в полном наборе единиц, \\(N_c\\) — число тех же элементов после объединения единиц, попадающих в один класс.\n\n\n\n\n\n\nИнтерпретация\n\n\nСложность картограмм показывает на какое количество однородных областей делится изображение при выбранном методе классификации и количестве классов.\n\n\n\n\n\n\n\n\n\nПрименение\n\n\nНаилучшие картограммы получаются при оптимальном сочетании добротности классификации (GADF) и визуальной сложности (C)."
  },
  {
    "objectID": "04_Diagrams.html#визуальная-сложность-1",
    "href": "04_Diagrams.html#визуальная-сложность-1",
    "title": "Значки и картодиаграммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nВ зависимости от выбранного метода классификации и количества классов будет меняться характер распределения и его визуальная сложность.\n\nФишер-Дженкс (k = 8, C = 0.47)"
  },
  {
    "objectID": "04_Diagrams.html#визуальная-сложность-2",
    "href": "04_Diagrams.html#визуальная-сложность-2",
    "title": "Значки и картодиаграммы",
    "section": "Визуальная сложность",
    "text": "Визуальная сложность\nВ зависимости от выбранного метода классификации и количества классов будет меняться характер распределения и его визуальная сложность.\n\nКвантили (k = 4, C = 0.31)"
  },
  {
    "objectID": "04_Diagrams.html#библиография",
    "href": "04_Diagrams.html#библиография",
    "title": "Значки и картодиаграммы",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций"
  },
  {
    "objectID": "04_Diagrams.html#концептуальная-точка",
    "href": "04_Diagrams.html#концептуальная-точка",
    "title": "Значки и картодиаграммы",
    "section": "Концептуальная точка",
    "text": "Концептуальная точка\nЦентроид"
  },
  {
    "objectID": "04_Diagrams.html#оптимизация",
    "href": "04_Diagrams.html#оптимизация",
    "title": "Значки и картодиаграммы",
    "section": "Оптимизация",
    "text": "Оптимизация\n\n\nОптимальный размер\n\nРазмер диаграмм должен быть таким, чтобы он не давал избыточного перекрытия или наоборот пустоты на карте.\nЭкспериментальные исследования говорят, что человек недооценивает размеры объектов. Можно использовать компенсацию Флэннери:\n\\[\n\\widehat S = 1.01902 \\cdot S^{1.14325}\n\\]\n\n\nОптимальное размещение\n\nРасположение концептуальной точки необходимо определять алгоритмически:\n\nцентроид, точка в полигоне, центр максимальной вписанной окружности.\n\nВ случае использования значков они могут быть раздвинуты для обеспечения читаемости в ущерб точности расположения"
  },
  {
    "objectID": "04_Diagrams.html#значки-и-картодиаграммы-1",
    "href": "04_Diagrams.html#значки-и-картодиаграммы-1",
    "title": "Значки и картодиаграммы",
    "section": "Значки и картодиаграммы",
    "text": "Значки и картодиаграммы\nВ западной (американской) школе эти способы изображения считаются одним — proportional symbols.\n\nСимволы диаграмм размещаются в точках, но точки бывают двух видов — реальные и концептуальные.\nРеальные точки соответствуют точечным объектам в масштабе картографирования\nКонцептуальные точки используются для размещения диаграмм внутри площадных территориальных единиц.\n\n\n\n\n\n\n\nКонцептуальные точки\n\n\nПоиск оптимального местоположения для концептуальной точки — отдельная вычислительная задача"
  },
  {
    "objectID": "04_Diagrams.html#концептуальная-точка-1",
    "href": "04_Diagrams.html#концептуальная-точка-1",
    "title": "Значки и картодиаграммы",
    "section": "Концептуальная точка",
    "text": "Концептуальная точка\nТочка на поверхности"
  },
  {
    "objectID": "04_Diagrams.html#концептуальная-точка-2",
    "href": "04_Diagrams.html#концептуальная-точка-2",
    "title": "Значки и картодиаграммы",
    "section": "Концептуальная точка",
    "text": "Концептуальная точка\nЦентр максимальной вписанной окружности"
  },
  {
    "objectID": "04_Diagrams.html#центр-макс.-вписанной-окружности",
    "href": "04_Diagrams.html#центр-макс.-вписанной-окружности",
    "title": "Значки и картодиаграммы",
    "section": "Центр макс. вписанной окружности",
    "text": "Центр макс. вписанной окружности\nПостроить диаграмму Вороного для точек на границе региона"
  },
  {
    "objectID": "04_Diagrams.html#центр-макс.-вписанной-окружности-1",
    "href": "04_Diagrams.html#центр-макс.-вписанной-окружности-1",
    "title": "Значки и картодиаграммы",
    "section": "Центр макс. вписанной окружности",
    "text": "Центр макс. вписанной окружности\nОтобрать только те ребра диаграммы, которые располагаются внутри регионы (CONTAINS_PROPERLY):"
  },
  {
    "objectID": "04_Diagrams.html#центр-макс.-вписанной-окружности-2",
    "href": "04_Diagrams.html#центр-макс.-вписанной-окружности-2",
    "title": "Значки и картодиаграммы",
    "section": "Центр макс. вписанной окружности",
    "text": "Центр макс. вписанной окружности\nДля всех вершин ребер вычислить расстояние до границы региона"
  },
  {
    "objectID": "04_Diagrams.html#центр-макс.-вписанной-окружности-3",
    "href": "04_Diagrams.html#центр-макс.-вписанной-окружности-3",
    "title": "Значки и картодиаграммы",
    "section": "Центр макс. вписанной окружности",
    "text": "Центр макс. вписанной окружности\nВыбрать среди них вершину с максимальным расстоянием"
  }
]