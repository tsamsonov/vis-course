[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Визуализация пространственных данных",
    "section": "",
    "text": "Добро пожаловать на курс “Визуализация пространственных данных”! В этом курсе мы научимся создавать карты программным путём, используя возможности QGIS."
  },
  {
    "objectID": "01_Basics.html",
    "href": "01_Basics.html",
    "title": "1  Базовые операции рендеринга",
    "section": "",
    "text": "Визуализация данных в QGIS возможна не только посредством графического интерфейса, но также путем программной компоновки карт. Преимущество программного отображения в QGIS по сравнению с тем, что вы можете сделать на чистом Python — в том, что становится доступен невероятно мощный функционал и производительность графического движка QGIS.\n\n\nПервая операция, которая может быть полезной, это получение ссылки на экземпляр проекта:\n\nQgsProject.instance()\n\nГлавное, для чего он может быть полезен — это управление списком отображаемых слоёв. Можно получить список слоев или удалить все слои из содержимого карты:\n\nQgsProject.instance().mapLayers().values() # список слоёв\nQgsProject.instance().removeAllMapLayers() # удаление всех слоёв\n\nЕсли необходимо чтобы скрипт собирал карту с нуля каждый раз при запуске, следует расположить вызов removeAllMapLayers() в самом начале. Это будет гарантировать, что сборка проекта начнется с чистого листа.\nСборку логично начать с добавления слоёв, которое осуществляется посредством следующей команды:\n\nlayer = iface.addVectorLayer(path)\nlayer = iface.addRasterLayer(path)\n\nгде path — полный путь к данным, layer — переменная, которая будет хранить ссылку на слой в таблице содержания. Вы можете ее называть любым подходящим именем.\nОбратите внимание на переменную iface. Это самая важная переменная в скрипте. Создавать её не нужно, она доступна всегда по умолчанию и представляет собой экземпляр класса QgsInterface. Через него вы получаете доступ к компоненте карты, меню, панелям инструментов и другим компонентам.\n\n\n\nПосле того как слой добавлен на карту, можно заниматься его оформлением. Для того необходимо получить символику:\n\nsymbol = layer.renderer().symbol()\n\nВ целом, не обязательно записывать символ в какую-то переменную, но если вы планируете осуществлять более чем одну настройку символа, то лучше это сделать, чтобы каждый раз не вызывать указанную последовательность функций.\nЧасть функций по оформлению слоя доступна непосредственно через объект символа. Например, глобальный цвет, толщину линии или размер пунсона можно задать следующим образом:\n\nsymbol.setColor(color) # заливка\nsymbol.setWidth(width) # толщина\nsymbol.setSize(size)   # размер\n\nгде color — объект класса QColor, определяющий цвет (см. далее).\nБольшинство же настроек символики делается через слои символов, извлечь каждый из которых можно следующим образом:\n\nsymbol.symbolLayer(i)\n\nгде i — номер слоя символа. По умолчанию каждый символ имеет один слой с индексом 0. Для доступа к нему соответственно надо вызвать symbol.symbolLayer(0).\nНапример, цвет и паттерн линии или обводки полигона устанавливаются так:\n\nsymbol.symbolLayer(0).setStrokeColor(color) # цвет линии\nsymbol.symbolLayer(0).setStrokeStyle(style) # паттерн линии\n\nгде style — экземпляр класс PenStyle.\nДля создания цветов и стилей линий существуют свои классы. Цвет можно создать по названию или цветовым компонентам:\n\ncolor = QColor('azure')\ncolor = QColor(120, 240, 75)\n\nА вот создание стиля линии делается не через нативные классы QGIS, а посредством классов библиотеки Qt, на которой реализован вообще весь QGIS:\n\nstyle = Qt.PenStyle(Qt.NoPen) # Нет обводки\nstyle = Qt.PenStyle(Qt.DotLine) # Пунктир\nstyle = Qt.PenStyle(Qt.SolidLine) # Сплошная\n\nПолный перечень стилей Qt согласно официальной документации выглядит так:\n\n\n\nСтили линий Qt\n\n\n\n\n\nДля того чтобы включить подписи слоя, необходимо сделать ряд настроек. Для начала следует получить экземпляры классов, отвечающих за настройки слоя в целом и форматирование текста в частности:\n\nsettings  = QgsPalLayerSettings()\ntext_format = QgsTextFormat()\n\nДалее осуществляется последовательная настройка подписей:\n\ntext_format.setFont(QFont(\"Arial\", 14))\ntext_format.setSize(14)\n\nsettings.enabled = True\nsettings.fieldName = \"NAME\"\nsettings.setFormat(text_format)\n\nНа основе полученных настроек необходимо инициализировать класс подписей и назначить его слою:\n\nlabeling = QgsVectorLayerSimpleLabeling(settings)\nlayer.setLabelsEnabled(True)\nlayer.setLabeling(labeling)\n\n\n\n\nЧтобы осуществить фильтрацию слоя по атрибуту, достаточно активировать соответствующую настройку посредством setSubsetString:\n\nlayer.setSubsetString(\"SIZE > 2000\")\n\n\n\n\nПосле того как вы настроили внешний вид слоя, необходимо сделать 2 вещи: инициировать его перерисовку на карте, а также обновить его легенду, для того чтобы она соответствовала символике. Делается это следующим образом:\n\nlayer.triggerRepaint() # перерисовать слой\niface.layerTreeView().refreshLayerSymbology(layer.id()) # обновить легенду\n\nОбратите внимание на то, что легендой слоя владеет не сам слой, а компонента таблицы содержания (layerTreeView).\nКоманды перерисовки карты и легенды должны быть вызваны для каждого слоя, оформление которого изменено программным путём. Если необходимо одинаковым образом обновить все слои карты (например, задать им прозрачность или покрасить в черный цвет), то это можно сделать в цикле:\n\nlayers = QgsProject.instance().mapLayers().values()\nfor layer in layers:\n  ... # изменение символики\n  ... # изменение символики\n  layer.triggerRepaint()\n  iface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "objectID": "01_Basics.html#пример-использования",
    "href": "01_Basics.html#пример-использования",
    "title": "1  Базовые операции рендеринга",
    "section": "1.2 Пример использования",
    "text": "1.2 Пример использования\nВ данном примере рассматривается добавление на карту и раскрашивание полигона суши:\n\nQgsProject.instance().removeAllMapLayers()\nland = '/Volumes/Data/Spatial/Natural Earth/natural_earth_vector.gpkg|layername=ne_110m_land'\n\nlayer = iface.addVectorLayer(land,'','ogr')\n\nfill = QColor (250,250,250)\nstroke = QColor('darkblue')\n\nsymbol = layer.renderer().symbol()\nsymbol.setColor(fill)\npen = Qt.PenStyle(Qt.SolidLine)\nsymbol.symbolLayer(0).setStrokeStyle(pen)\nsymbol.symbolLayer(0).setStrokeColor(stroke)\n\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())\n\nРезультат выглядит следующим образом:\n\n\n\nПрограммное добавление полигона суши в QGIS"
  },
  {
    "objectID": "calibration.html",
    "href": "calibration.html",
    "title": "Appendix A — Калибровка монитора",
    "section": "",
    "text": "Для калибровки используются колориметр и спектрометр. Основной прибор — это колоритметр, он измеряет характеристики излучения оттенков красного, синего и зеленого цвета и их комбинаций (включая градации серого от белого до черного). Спектрометр является вспомогательным прибором, который позволяет сделать коррекцию результатов колориметрических измерений путем более точных замеров характеристик излучения. В простейшем случае можно обойтись без спектрометра (но цветовой профиль получается менее точным).\nДля калибровки мы будем использовать программное обеспечение DisplayCAL и колориметр X-Rite i1 Display:\n\n\n\nПрограммное обеспечение для калибровки дисплея Display CAL\n\n\nНеобходимо загрузить DisplayCAL и установить его, а также подключить колориметр к порту USB.\nПри открытии программы необходимо выбрать ваш монитор и колоритметр в списках Дисплей и Инструмент. Поскольку спектрометра у нас нет, Коррекцию установите автоматическую:\n\n\n\nОсновное окно DisplayCAL\n\n\nЕсли колориметр отсутствует в списке инструментов, выберите в меню Инструменты пункт Обнаруженные устройства отображения и инструменты, чтобы произвести поиск заново:\n\n\n\nПринудительное обнаружение устройств\n\n\nПосле этого можно приступать к калибровке, если соблюдено следующее условие:\n\nВажно: перед началом калибровки монитор должен быть включён не менее 30 минут, а различные динамические настройки, повышающие чёткость изображения, ночной режим и прочее необходимо отключить.\n\nПосле того как монитор и колориметр определены, можно запускать калибровку, нажав для этого кнопку Калибровка и характеризация. Появится небольшое диалоговое окно, с помощью которого можно изменить положение и размеры области экрана, в пределах которой будут проводиться измерения:\n\n\n\nУстановка области калибровки\n\n\nВ центр этой области необходимо разместить колоритметр линзой в сторону экрана, а противовес свесить за экраном:\n\n\n\nУстановка колориметра\n\n\nПосле этого нужно нажать Начать измерения. В течение нескольких минут цветовые ползунки должны стабилизироваться в определенном положении:\n\n\n\nИсходное положение при калибровке\n\n\nДалее необходимо, меняя настройки монитора, привести ползунок яркости и ползунки трех цветовых компонент в центральное положение (или максимально близко к нему), что будет означать примерно сопоставимую интенсивность трех типов световых излучателей R,G,B.:\n\n\n\nПосле регулировки настроек монитора\n\n\nЕсли регулировки выполнены, можно нажать Продолжайте калибровку. В течение нескольких минут DisplayCAL будет показывать колориметру цветовые пятна разной яркости, насыщенности и цветового тона и выполнять измерения:\n\n\n\nКалибровка в процессе\n\n\nПосле калибровки будет запущен процесс создания цветового профиля и LUT (Look Up Table) для видеокарты:\n\n\n\nПроцесс создания цветового профиля\n\n\nЕсли профиль монитора успешно создан, то в конце процедуры вы увидите следующий диалог. Чтобы сразу же воспользоваться профилем, необходимо выбрать опцию Установить профиль:\n\n\n\nОкончание калибровки и параметры созданного профиля\n\n\nНазвание профиля и путь к нему можно посмотреть на вкладке Профилирование:\n\n\n\nПараметры созданного профиля\n\n\nЕсли вы пользуетесь операционной системой Windows, то получившися цветовой профиль должен быть активирован в настройках дисплея:\n\n\n\nАктивированный цветовой профиль в настройках дисплея.\n\n\nНа этом всё! 🤓"
  },
  {
    "objectID": "02_Scales.html",
    "href": "02_Scales.html",
    "title": "2  Градуированные символы для визуализации атрибутов",
    "section": "",
    "text": "В данном упражнении мы будем работать со слоем стран, поэтому его необходимо загрузить:"
  },
  {
    "objectID": "02_Scales.html#доступ-к-атрибутивным-полям",
    "href": "02_Scales.html#доступ-к-атрибутивным-полям",
    "title": "2  Градуированные символы для визуализации атрибутов",
    "section": "2.1 Доступ к атрибутивным полям",
    "text": "2.1 Доступ к атрибутивным полям\nЧтобы узнать перечень атрибутов, можно использовать метод fields():\n\nfields = [field.name for field in layer.fields()]\nprint(fields)\n\nАналогичным образом можно вытащить все значения атрибута:\n\nadmin = [feature[\"ADMIN\"] for feature in layer.getFeatures()]\nprint(admin)"
  },
  {
    "objectID": "02_Scales.html#градуированные-символы",
    "href": "02_Scales.html#градуированные-символы",
    "title": "2  Градуированные символы для визуализации атрибутов",
    "section": "2.2 Градуированные символы",
    "text": "2.2 Градуированные символы\nДанный метод может использоваться дли автоматизации таких способов как картограммы, картодиаграммы, значки. В этом упражнении мы рассмотрим как создать каждый интервал вручную.\nПрежде всего необходимо понимать, какой тип геометрии у слоя:\n\ngeom_type = layer.geometryType()\n\nДалее нужно создать пустой список интервалов классификации:\n\nranges = []\n\nЕсли известно количество классов (N), которое необходимо получить, следует заполнить этот список объектами интервалов. Для каждого интервала надо вычислить его цвет, минимальную и максимальную границу, а также подпись (то, что будет отображаться в легенде). Далее на основе этих данных создается объект символа (QgsSymbol) и объект интервала (QgsRendererRange), который добавляется в список интеовалов. Примерный шаблон кода выглядит следующим образом:\n\nfor i in range(N):\n  col = ...\n  low = ...\n  high = ...\n  label = ...\n  \n  sym = QgsSymbol.defaultSymbol(geom_type)\n  sym.setColor(col)\n  interval = QgsRendererRange(low, high, sym, label)\n  \n  ranges.append(interval)\n\nДалее на основе созданных интервалов можно уже соорудить визуализатор градуированных символов:\n\nrenderer = QgsGraduatedSymbolRenderer('POP_EST', ranges)\n\nЧтобы этот визуализатор заработал, необходимо выбрать, к какому методу классификации относятся выбранные вами границы. Поскольку они сформированы вручную, нужно выбрать соответствующий метод:\n\nclassreg = QgsApplication.classificationMethodRegistry()\nnms = classreg.methodNames()\nprint(nms)\n\nБудет выведено нечто следующее:\n{'Equal Count (Quantile)': 'Quantile', 'Equal Interval': 'EqualInterval', 'Fixed Interval': 'Fixed', 'Logarithmic Scale': 'Logarithmic', 'Natural Breaks (Jenks)': 'Jenks', 'Pretty Breaks': 'Pretty', 'Standard Deviation': 'StdDev'}\nС методами автоматической классификации мы познакомимся далее. А пока что надо выбрать вариант Fixed и присвоить его визуализатору:\n\nmethod = classreg.method('Fixed')\nrenderer.setClassificationMethod(method)\n\nНаконец, после того как визуализатор готов, его нажно назначить слою и обновить изображение:\n\nlayer.setRenderer(renderer)\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "objectID": "02_Scales.html#формирование-интервалов",
    "href": "02_Scales.html#формирование-интервалов",
    "title": "2  Градуированные символы для визуализации атрибутов",
    "section": "2.2 Формирование интервалов",
    "text": "2.2 Формирование интервалов\nДанный метод может использоваться дли автоматизации таких способов как картограммы, картодиаграммы, значки. В этом упражнении мы рассмотрим как создать каждый интервал классификации вручную.\nПрежде всего необходимо понимать, какой тип геометрии у слоя:\n\ngeom_type = layer.geometryType()\n\nДалее нужно создать пустой список интервалов классификации:\n\nranges = []\n\nЕсли известно количество классов (N), которое необходимо получить, следует заполнить этот список объектами интервалов. Для каждого интервала надо вычислить его цвет, минимальную и максимальную границу, а также подпись (то, что будет отображаться в легенде). Далее на основе этих данных создается объект символа (QgsSymbol) и объект интервала (QgsRendererRange), который добавляется в список интеовалов. Примерный шаблон кода выглядит следующим образом:\n\nfor i in range(N):\n  col = ...\n  low = ...\n  high = ...\n  label = ...\n  \n  sym = QgsSymbol.defaultSymbol(geom_type)\n  sym.setColor(col)\n  interval = QgsRendererRange(low, high, sym, label)\n  \n  ranges.append(interval)\n\nДалее на основе созданных интервалов можно уже соорудить визуализатор градуированных символов:\n\nrenderer = QgsGraduatedSymbolRenderer('POP_EST', ranges)"
  },
  {
    "objectID": "02_Scales.html#назначение-ручного-метода-классификации",
    "href": "02_Scales.html#назначение-ручного-метода-классификации",
    "title": "2  Градуированные символы для визуализации атрибутов",
    "section": "2.3 Назначение ручного метода классификации",
    "text": "2.3 Назначение ручного метода классификации\nЧтобы визуализатор заработал, необходимо выбрать, к какому методу классификации относятся выбранные вами границы. Поскольку они сформированы вручную, нужно выбрать соответствующий метод:\n\nclassreg = QgsApplication.classificationMethodRegistry()\nnms = classreg.methodNames()\nprint(nms)\n\nБудет выведено нечто следующее:\n{'Equal Count (Quantile)': 'Quantile', 'Equal Interval': 'EqualInterval', 'Fixed Interval': 'Fixed', 'Logarithmic Scale': 'Logarithmic', 'Natural Breaks (Jenks)': 'Jenks', 'Pretty Breaks': 'Pretty', 'Standard Deviation': 'StdDev'}\nС методами автоматической классификации мы познакомимся далее. А пока что надо выбрать вариант Fixed и присвоить его визуализатору:\n\nmethod = classreg.method('Fixed')\nrenderer.setClassificationMethod(method)\n\nНаконец, после того как визуализатор готов, его нажно назначить слою и обновить изображение:\n\nlayer.setRenderer(renderer)\nlayer.triggerRepaint()\niface.layerTreeView().refreshLayerSymbology(layer.id())"
  }
]