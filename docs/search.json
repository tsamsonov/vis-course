[
  {
    "objectID": "01_BasicAlgorithms.html#компьютерная-графика",
    "href": "01_BasicAlgorithms.html#компьютерная-графика",
    "title": "Основы компьютерной графики",
    "section": "Компьютерная графика",
    "text": "Компьютерная графика\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\nВизуальный аспект: компьютер → человек\nИнтерактивный аспект: человек → компьютер"
  },
  {
    "objectID": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "href": "01_BasicAlgorithms.html#связь-с-компьютерным-зрением",
    "title": "Основы компьютерной графики",
    "section": "Связь с компьютерным зрением",
    "text": "Связь с компьютерным зрением\nКомпьютерная графика: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\nКомпьютерное зрение: определение параметров сцены и погруженных в нее объектов при заданных допущениях.\n\n[Lesage, Visvalingam, 2002]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер",
    "href": "01_BasicAlgorithms.html#графический-конвейер",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВ статичной сцене графический конвейер определяет последовательность отрисовки изображения."
  },
  {
    "objectID": "01_BasicAlgorithms.html#графический-конвейер-1",
    "href": "01_BasicAlgorithms.html#графический-конвейер-1",
    "title": "Основы компьютерной графики",
    "section": "Графический конвейер",
    "text": "Графический конвейер\n\nВзаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения"
  },
  {
    "objectID": "01_BasicAlgorithms.html#структура-2d-приложения",
    "href": "01_BasicAlgorithms.html#структура-2d-приложения",
    "title": "Основы компьютерной графики",
    "section": "Структура 2D-приложения",
    "text": "Структура 2D-приложения\n\n\n\n\n\nГрафическая платформа отвечает за взаимодействие приложения и оборудования\nМодель приложения (application model) представляет визуализируемые данные\nКлиентская область (client area) определяет пространство, в котором приложение выполняет отрисовку.\nПорт просмотра (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели"
  },
  {
    "objectID": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "href": "01_BasicAlgorithms.html#эволюция-графической-платформы",
    "title": "Основы компьютерной графики",
    "section": "Эволюция графической платформы",
    "text": "Эволюция графической платформы\n1980-е — начало 1990-х (Apple QuickDraw, Microsoft GDI): отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка примитивов: геометрических форм или битмапов (пиксельных карт).\n\nКаждый примитив заполняется путем вызова определенной функции (например, FillRectangle).\nРазмер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.\n\nСередина 1990-х — н.вр. Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат."
  },
  {
    "objectID": "01_BasicAlgorithms.html#непосредственный-режим",
    "href": "01_BasicAlgorithms.html#непосредственный-режим",
    "title": "Основы компьютерной графики",
    "section": "Непосредственный режим",
    "text": "Непосредственный режим\nВ непосредственном режиме (immediate mode) клиент через графическую платформу обращается непосредственно к выводящему устройству.\n\nЗапись примитивов, переданных приложением, не выполняется.\nПри смене сцены приложение должно перерисовать ее целиком."
  },
  {
    "objectID": "01_BasicAlgorithms.html#сохраненный-режим",
    "href": "01_BasicAlgorithms.html#сохраненный-режим",
    "title": "Основы компьютерной графики",
    "section": "Сохраненный режим",
    "text": "Сохраненный режим\nВ сохраненном режиме (retained mode) графическая платформа хранит спецификацию сцены в виде графа сцены (scene graph).\n\nОбъекты могут добавляться в граф сцены последовательно.\nКаждое изменение графа приводит к перерисовке сцены"
  },
  {
    "objectID": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "href": "01_BasicAlgorithms.html#процедурный-и-декларативный-подходы",
    "title": "Основы компьютерной графики",
    "section": "Процедурный и декларативный подходы",
    "text": "Процедурный и декларативный подходы\n\n\nПроцедурный код пишется на императивном языке программирования\n\nОписывает действия\nСтандарт при взаимодействии с графической платформой\nВ геоинформационных пакетах применяется на низком уровне, невидимом для пользователя\n\n\nДекларативные спецификации фиксируются на языке разметки\n\nОписывают результаты\nВспомогательное средство в графических платформах\nВ геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "href": "01_BasicAlgorithms.html#отрисовка-векторных-объектов",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка векторных объектов",
    "text": "Отрисовка векторных объектов\n\nДве основных операции: обводка и заливка\nВ случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\nУстановить тип отображаемого объекта\nОрганизовать обход по всем уровням вложенности с помощью цикла\nНа самом низком уровне вложенности получить матрицу координат.\nПоследовательно соединяя соседние координаты в матрице, отрисовать границу отрезками."
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\nАлгоритм Брезенхема (Bresenham 1965)\ndraw_line(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nCистема экранных координат \\(ij\\), где \\(i\\) — строка (увеличивается сверху вниз), \\(j\\) — столбец (увеличивается слева направо),\n\n\\((i_0, j_0)\\) — начальная точка отрезка в экранных координатах\n\\((i_1, j_1)\\) — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: \\[\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}\\]\nВыразив \\(i\\), получаем: \\[i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "href": "01_BasicAlgorithms.html#отрисовка-отрезков-1",
    "title": "Основы компьютерной графики",
    "section": "Отрисовка отрезков",
    "text": "Отрисовка отрезков\n\n\nСтандартно рассматривается отрисовка линии, которая располагается в секторе В-ЮВ, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 &lt; j_1,~i_0 \\leq i_1\\);\n\\(j_1 - j_0 \\geq i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-1",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора В-ЮВ алгоритм опирается на координаты \\(x\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{blue}{d = di / dj}\\);\n\\(\\color{blue}{i = i_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{blue}{j = j_0, ... j_1}\\), выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{blue}{i = i + \\texttt{sign}(di)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора В-СВ (только \\(i\\) будет уменьшаться).\nОбозначим случай draw_line_byJ(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-2",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\n\n\nАльтернативно рассматривается отрисовка линии, которая располагается в секторе Ю-ЮВ, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n\\(j_0 \\geq 0,~i_0 \\geq 0\\);\n\\(j_0 \\leq j_1,~i_0 &lt; i_1\\);\n\\(j_1 - j_0 &lt; i_1 - i_0\\)."
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-3",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля сектора Ю-ЮВ алгоритм опирается на координаты \\(i\\):\n\n\nВычисляем заранее:\n\n\\(dj = j_1 - j_0\\).\n\\(di = i_1 - i_0\\).\n\\(\\color{red}{d = dj / di}\\);\n\\(\\color{red}{j = j_0}\\);\n\\(e = 0\\)\n\n\nДля \\(\\color{red}{i = i_0, ... i_1}\\) выполняем:\n\nРисуем пиксель \\((i, j)\\).\nОбновляем ошибку \\(e = e + |d|\\).\nЕсли \\(e \\geq 0.5\\), то:\n\n\n\\(\\color{red}{j = j + \\texttt{sign}(dj)}\\),\n\\(e = e - 1\\).\n\n\n\nИспользование функции \\(\\texttt{sign}\\) позволяет применять алгоритм также и для сектора Ю-ЮЗ (только \\(j\\) будет уменьшаться).\nОбозначим случай draw_line_byI(i0, j0, i1, j1, image, color)"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "href": "01_BasicAlgorithms.html#алгоритм-брезенхэма-4",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм Брезенхэма",
    "text": "Алгоритм Брезенхэма\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на Python:\ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) &lt; abs(j1 - j0): # пологая линия\n        if j0 &gt; j1:\n            draw_line_byX(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byX(i0, j0, i1, j1, image, color)\n    else:\n        if i0 &gt; i1:                 # крутая линия\n            draw_line_byY(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byY(i0, j0, i1, j1, image, color)\nгде abs() — функция вычисления модуля."
  },
  {
    "objectID": "01_BasicAlgorithms.html#заливка-полигона",
    "href": "01_BasicAlgorithms.html#заливка-полигона",
    "title": "Основы компьютерной графики",
    "section": "Заливка полигона",
    "text": "Заливка полигона"
  },
  {
    "objectID": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "href": "01_BasicAlgorithms.html#алгоритм-сканирующей-линии",
    "title": "Основы компьютерной графики",
    "section": "Алгоритм сканирующей линии",
    "text": "Алгоритм сканирующей линии\nДля каждого \\(i_k = i_{min},...,i_{max}\\) получить упорядоченное по возрастанию множество \\(J = \\{j_0, j_1, ..., j_{n-1}\\}\\) столбцов пересечений с исходными линиями:\n\nДля каждой линии \\(l_m, m = 0,...,N-1\\):\n\n\nвычислить флаг пересечения \\(f: i^m_0 &gt; i_k \\neq i^m_1 &gt; i_k\\);\nесли \\(f = \\texttt{TRUE}\\), то\n\nвычислить \\(j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}\\);\nдобавить \\(j^m\\) в множество \\(J\\).\n\n\n\nЕсли \\(J\\) не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n\\[\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor\\]"
  },
  {
    "objectID": "01_BasicAlgorithms.html#библиография",
    "href": "01_BasicAlgorithms.html#библиография",
    "title": "Основы компьютерной графики",
    "section": "Библиография",
    "text": "Библиография\n\n\n\nСамсонов Т. Е. Визуализация пространственных данных: курс лекций\n\n\n\n\nBresenham, J. E. 1965. «Algorithm for Computer Control of a Digital Plotter». IBM Systems Journal 4 (1): 25–30. https://doi.org/10.1147/sj.41.0025."
  }
]