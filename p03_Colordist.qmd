---
jupyter: python3
execute:
  eval: false
---

# Анализ цветовых щкал

Одна из ключевых задач картографической визуализации --- обеспечить наглядность и равномерность цветовых шкал, используемых при визуализации данных. Использование неперцептивных цветовых пространств часто ведет к тому, что визальные различия между соседними градациями шкалы могут значительно варьироваться в пределах шкалы. В данном упражнении мы научимся извлекать уже заданную шкалу из слоя и оценивать ее цветовую равномерность.

## Установка модуля colour

Перцептивная оценка цветовых градиентов требует вычислений в перцептивных цветовых пространствах. При этом стандартный класс `QColor` в QGIS ожидаемо [поддерживает](https://doc.qt.io/qtforpython-5/PySide2/QtGui/QColor.html) только общеупотребительные пространства **RBG**, **CMYK**, **HSL** и **HSV**:

![Методы класса QColor для возврата значения цвета в виде массива цветовых компонент](images/paste-83DE56B6.png)

Для преобразования из этих пространств в перцептивные можно использовать библиотеку [colour](https://colour.readthedocs.io/en/develop/index.html) . Чтобы ее установить в Python при QGIS введите в консоли Python следующие команды:

```{python}
import pip
pip.main(['install', 'colour'])
```

После этого можно подключить требуемые библиотеки в начале скрипта:

```{python}
import numpy as np
import colour
```

## Извлечение цветовой шкалы

Для того чтобы выполнить анализ равномерности цветовой шкалы, необходимо получить цвета всех её классов. Для этого необходимо выполнить следующую последовательность действий:

1.  Выбрать активный слой (`layer = iface.activeLayer()`).
2.  Получить его рендерер (`renderer = layer.renderer()`).
3.  Получить список интервалов рендерера (`ranges = renderer.ranges()`).
4.  Извлечь цвет для каждого интервала и наполнить этими цветами массив.

Если известен список интервалов, то единичный можно получить просто по индексу. Печатается он довольно наглядно:

```
>>> ranges[0]
<QgsRendererRange: 0 - 364700 (0 - 364700)>
```

Доступ к цвету интервала можно получить через символ и его цвет:

```
>>> ranges[0].symbol().color()
<PyQt5.QtGui.QColor object at 0x194440dd0>
```

В таком виде он, конечно, не очень удобен для последующего анализа. Поэтому можно воспользоваться одной из вышеприведенных функций для получения массива цветов:

```
>>> ranges[0].symbol().color().getRgb()
(255, 255, 255, 255)
```

Можно теперь объединить все эти операции в одну, получив массив цветовых массивов. Для удобства каждый цвет целесообразно преобразовать в массив `numpy`:

```{python}
colors = [
  np.array(r.symbol().color().getRgb())
  for r in renderer.ranges()
]
```

Имея в распоряжении массив цветов, можно приступать к оценке качества цветовой шкалы.

## Преобразование цветовых пространств

Цветовые расстояния целесообразно рассчитывать в перцептивных цветовых пространствах. Для этих целей как правило используют CIE LAB. Следовательно, полученные цвета RGB необходимо в это пространство преобразовать. Для начала необходимо инициализировать эти цветовые пространства в `colour`:

```{python}
srgb = colorio.cs.SRGB255()
slab = colorio.cs.CIELAB()
```

Приставка 255 указывает, что цвета RGB будут задаваться в диапазоне от 0 до 255 --- что соответствует стандартному формату, возвращаемому QColor.

Как мы уже знаем, для преобразований между любыми цветовыми пространствами в качестве прокси используется пространство XYZ с виртуальными источниками освещения. Соответственно, любое цветовое пространство в `colour` реализует 2 метода: `to_xyz100()` и `from_xyz100()` . Имея их, можно получить искомое преобразование на примере цвета `[255, 217, 64]` следующим образом:

```{python}
rgb = np.array([255, 217, 64])
xyz = srgb.to_xyz100(rgb)
lab = slab.from_xyz100(xyz)
```

Или одним выражением:

```{python}
lab = slab.from_xyz100(srgb.to_xyz100(rgb))
```

Чтобы сделать это преобразование для каждого элемента списка цветов можно использовать уже знакомый нам подход. При этом важно избавиться от 4-й компоненты цвета (прозрачности):

```{python}
labs = [slab.from_xyz100(srgb.to_xyz100(color[0:3])) for color in colors]
```

## Вычисление цветовых расстояний

Существует несколько распространенных методов вычисления цветовых расстояний (цветоразностей). Поскольку пространство CIE LAB является перцептивным, то предполагается, что изменения цвета в нем происходят линейно. Поэтому простейший подход __CIE76__ к вычислению цветоразностей в этом пространстве базируется на Евклидовом расстоянии:

$$\Delta E^*_{ab} = \sqrt{(\Delta L^*)^2 + (\Delta a^*)^2 + (\Delta b^*)^2}$$
При этом значение $\Delta E^*_{ab} \approx 2.3$ соответствует едва различимой цветоразности. Это означает, что цвета с такой разностью будет трудно дифференцировать (хотя, конечно, все еще зависит от условий наблюдения и размера цветового пятна). Существуют и более сложные формулы __CIE94__, __CIE2000__ и __CMC__, в которых вводятся дополнительные перцептивные корректировки. 

Для вычисления цветовых разностей используйте соответствующие функции:
```{python}
colorio.diff.ciede76(lab1, lab2)
colorio.diff.ciede94(lab1, lab2)
colorio.diff.ciede2000(lab1, lab2)
colorio.diff.cmc(lab1, lab2)
```

где `lab1` и `lab2` — вектора `numpy` с цветами в пространстве CIE LAB.

Применительно к вектору таких цветов все расстояния между соседями можно вычислить в цикле:
```{python}
labdist = []
for i in range(len(labs)-1):
  labdist.append(colorio.diff.ciede76(lab[i], labs[i+1]))
```

## Анализ цветовых расстояний

Для характеристики цветовых расстояний полезно посчитать их описательные статистики: среднее, стандартное отклонение, размах вариации. Для этого импортируем модуль _statistics_:
```{python}
import statistics as st

st.fmean(labdist)
st.stdev(labdist)
min(labdist)
max(labdist)
```