---
title: "Основы компьютерной графики"
subtitle: "Визуализация пространственных данных"
date: today
date-format: long
author: "Самсонов Тимофей Евгеньевич"
execute:
  echo: false
  freeze: true
jupyter: python3
format:
  revealjs: 
    theme: [default, custom.scss]
    margin: 0.2
    width: 1280
    height: 720
    slide-number: true
    footer: "Самсонов Т. Е. Визуализация пространственных данных: курс лекций"
    header-includes: <link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/pt-sans" type="text/css"/>
bibliography: references.yaml
mainfont: PT Sans
---

## Компьютерная графика

Наука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.

-   Визуальный аспект: компьютер → человек
-   Интерактивный аспект: человек → компьютер

![](images/people.png){width="100%"}

## Связь с компьютерным зрением

**Компьютерная графика**: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.

**Компьютерное зрение**: определение параметров сцены и погруженных в нее объектов при заданных допущениях.

![](images/sketch.png){width="75%"}

\[Lesage, Visvalingam, 2002\]

## Графический конвейер

![](images/conveyor1.png){width="80%"}

В статичной сцене графический конвейер определяет последовательность отрисовки изображения.

## Графический конвейер

![](images/conveyor2.png){width="65%"}

Взаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения

## Структура 2D-приложения

::: columns
::: {.column width="40%"}
![](images/2D_app.png){width="100%"}
:::

::: {.column width="60%"}
-   **Графическая платформа** отвечает за взаимодействие приложения и оборудования

-   **Модель приложения** (application model) представляет визуализируемые данные

-   **Клиентская область** (client area) определяет пространство, в котором приложение выполняет отрисовку.

-   **Порт просмотра** (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели
:::
:::

## Эволюция графической платформы

**1980-е — начало 1990-х** *(Apple QuickDraw, Microsoft GDI)*: отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка *примитивов*: геометрических форм или битмапов (пиксельных карт).

-   Каждый примитив заполняется путем вызова определенной функции (например, `FillRectangle`).
-   Размер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.

**Середина 1990-х — н.вр.** Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат.

## Непосредственный режим

В **непосредственном режиме** *(immediate mode)* клиент через графическую платформу обращается непосредственно к выводящему устройству.

-   Запись примитивов, переданных приложением, не выполняется.
-   При смене сцены приложение должно перерисовать ее целиком.

![](images/immediate.png){width="100%"}

## Сохраненный режим

В **сохраненном режиме** *(retained mode)* графическая платформа хранит спецификацию сцены в виде графа сцены *(scene graph)*.

-   Объекты могут добавляться в граф сцены последовательно.
-   Каждое изменение графа приводит к перерисовке сцены

![](images/retained.png){width="100%"}

## Процедурный и декларативный подходы

::: columns
::: {.column width="50%"}
**Процедурный код** пишется на императивном языке программирования

-   Описывает *действия*
-   Стандарт при взаимодействии с графической платформой
-   В геоинформационных пакетах применяется на низком уровне, невидимом для пользователя
:::

::: {.column width="50%"}
**Декларативные спецификации** фиксируются на языке разметки

-   Описывают *результаты*
-   Вспомогательное средство в графических платформах
-   В геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)
:::
:::

## Отрисовка векторных объектов

-   Две основных операции: обводка и заливка
-   В случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.

Общий алгоритм для обводки:

1.  Установить тип отображаемого объекта
2.  Организовать обход по всем уровням вложенности с помощью цикла
3.  На самом низком уровне вложенности получить матрицу координат.
4.  Последовательно соединяя соседние координаты в матрице, отрисовать границу отрезками.

## Отрисовка отрезков

**Алгоритм Брезенхема** [@bresenham1965]

`draw_line(i0, j0, i1, j1, image, color)`

![](images/bresenham.gif){width="55%"}

## Алгоритм Брезенхэма

Cистема экранных координат $ij$, где $i$ — строка (увеличивается сверху вниз), $j$ — столбец (увеличивается слева направо),

-   $(i_0, j_0)$ — начальная точка отрезка в экранных координатах
-   $(i_1, j_1)$ — конечная точка отрезка в экранных координатах

Уравнение отрезка: $$\frac{i - i_0}{i_1-i_0} = \frac{j - j_0}{j_1-j_0}$$

Выразив $i$, получаем: $$i = \color{red}{\underbrace{\frac{i_1 - i_0}{j_1-j_0}}_{\textbf{d (уклон)}}} (j - j_0) + i_0$$

## Отрисовка отрезков

::: columns
::: {.column width="40%"}
*Стандартно* рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:

-   $j_0 \geq 0,~i_0 \geq 0$;
-   $j_0 < j_1,~i_0 \leq i_1$;
-   $j_1 - j_0 \geq i_1 - i_0$.
:::

::: {.column width="60%"}
![](images/coords.png){width="100%"}
:::
:::

## Алгоритм Брезенхэма

Для сектора `В-ЮВ` алгоритм опирается на координаты $x$:

::: columns
::: {.column width="50%"}
**Вычисляем заранее**:

-   $dj = j_1 - j_0$.
-   $di = i_1 - i_0$.
-   $\color{blue}{d = di / dj}$;
-   $\color{blue}{i = i_0}$;
-   $e = 0$
:::

::: {.column width="50%"}
**Для** $\color{blue}{j = j_0, ... j_1}$, **выполняем**:

1.  Рисуем пиксель $(i, j)$.
2.  Обновляем ошибку $e = e + |d|$.
3.  Если $e \geq 0.5$, то:

-   $\color{blue}{i = i + \texttt{sign}(di)}$,
-   $e = e - 1$.
:::
:::

Использование функции $\texttt{sign}$ позволяет применять алгоритм также и для сектора `В-СВ` (только $i$ будет уменьшаться).

Обозначим случай `draw_line_byJ(i0, j0, i1, j1, image, color)`

## Алгоритм Брезенхэма

::: columns
::: {.column width="50%"}
*Альтернативно* рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:

-   $j_0 \geq 0,~i_0 \geq 0$;
-   $j_0 \leq j_1,~i_0 < i_1$;
-   $j_1 - j_0 < i_1 - i_0$.
:::

::: {.column width="50%"}
![](images/coords2.png){width="55%"}
:::
:::

## Алгоритм Брезенхэма

Для сектора `Ю-ЮВ` алгоритм опирается на координаты $i$:

::: columns
::: {.column width="50%"}
**Вычисляем заранее**:

- $dj = j_1 - j_0$.
- $di = i_1 - i_0$.
- $\color{red}{d = dj / di}$;
- $\color{red}{j = j_0}$;
- $e = 0$

:::

::: {.column width="50%"}
__Для__ $\color{red}{i = i_0, ... i_1}$ __выполняем__:

1. Рисуем пиксель $(i, j)$.
2. Обновляем ошибку $e = e + |d|$.
3. Если $e \geq 0.5$, то:
  - $\color{red}{j = j + \texttt{sign}(dj)}$,
  - $e = e - 1$.
  
:::
:::

Использование функции $\texttt{sign}$ позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только $j$ будет уменьшаться).

Обозначим случай `draw_line_byI(i0, j0, i1, j1, image, color)`

## Алгоритм Брезенхэма

Для оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на **Python**:

```         
def draw_line(i0, j0, i1, j1, image, color):
    if abs(i1 - i0) < abs(j1 - j0): # пологая линия
        if j0 > j1:
            draw_line_byX(i1, j1, i0, j0, image, color)
        else:
            draw_line_byX(i0, j0, i1, j1, image, color)
    else:
        if i0 > i1:                 # крутая линия
            draw_line_byY(i1, j1, i0, j0, image, color)
        else:
            draw_line_byY(i0, j0, i1, j1, image, color)
```

где `abs()` — функция вычисления модуля.

## Заливка полигона

![](images/polyfill.png){width="70%"}

## Алгоритм сканирующей линии

Для каждого $i_k = i_{min},...,i_{max}$ получить упорядоченное по возрастанию множество $J = \{j_0, j_1, ..., j_{n-1}\}$ столбцов пересечений с исходными линиями:

1.  Для каждой линии $l_m, m = 0,...,N-1$:

-   вычислить флаг пересечения $f: i^m_0 > i_k \neq i^m_1 > i_k$;
-   если $f = \texttt{TRUE}$, то
    -   вычислить $j^m = j^m_0 + (j^m_1 - j^m_0)\frac{i_k - i^m_0}{i^m_1 - i^m_0}$;
    -   добавить $j^m$ в множество $J$.

2.  Если $J$ не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:

$$\lceil j_0 \rceil \to \lfloor j_1 \rfloor,~\lceil j_2 \rceil \to \lfloor j_3 \rfloor,~...~,~\lceil j_{n-2} \rceil \to \lfloor j_{n-1} \rfloor$$

## Библиография
