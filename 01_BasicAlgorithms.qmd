---
title: "Основы компьютерной графики"
subtitle: "Визуализация пространственных данных"
date: today
date-format: long
author: "Самсонов Тимофей Евгеньевич"
execute:
  echo: false
  freeze: true
engine: knitr
format:
  revealjs: 
    theme: [default, custom.scss]
    margin: 0.2
    width: 1280
    height: 720
    slide-number: true
    footer: "Самсонов Т. Е. Визуализация пространственных данных: курс лекций"
    header-includes: <link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/pt-sans" type="text/css"/>
bibliography: references.yaml
mainfont: PT Sans
---

## Компьютерная графика

Наука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.

-   Визуальный аспект: компьютер → человек
-   Интерактивный аспект: человек → компьютер

![](images/people.png){width="100%"}

## Мультидисциплинарность

-   физика

-   математика

-   человеческое зрение

-   человеко-машинное взимодействие

-   программная и аппаратная инженерия

-   графический дизайн

-   ...

## Связь с компьютерным зрением

**Компьютерная графика**: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.

**Компьютерное зрение**: определение параметров сцены и погруженных в нее объектов при заданных допущениях.

![](images/sketch.png){width="75%"}

\[Lesage, Visvalingam, 2002\]

## Графический конвейер

![](images/conveyor1.png){width="80%"}

В статичной сцене графический конвейер определяет последовательность отрисовки изображения.

## Графический конвейер

![](images/conveyor2.png){width="65%"}

Взаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения

## Структура 2D-приложения

::: columns
::: {.column width="40%"}
![](images/2D_app.png){width="100%"}
:::

::: {.column width="60%"}
-   **Графическая платформа** отвечает за взаимодействие приложения и оборудования

-   **Модель приложения** (application model) представляет визуализируемые данные

-   **Клиентская область** (client area) определяет пространство, в котором приложение выполняет отрисовку.

-   **Порт просмотра** (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели
:::
:::

## Эволюция графической платформы

**1980-е — начало 1990-х** *(Apple QuickDraw, Microsoft GDI)*: отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка *примитивов*: геометрических форм или битмапов (пиксельных карт).

-   Каждый примитив заполняется путем вызова определенной функции (например, `FillRectangle`).
-   Размер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.

**Середина 1990-х — н.вр.** Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат.

## Непосредственный режим

В **непосредственном режиме** *(immediate mode)* клиент через графическую платформу обращается непосредственно к выводящему устройству.

-   Запись примитивов, переданных приложением, не выполняется.
-   При смене сцены приложение должно перерисовать ее целиком.

![](images/immediate.png){width="100%"}

## Сохраненный режим

В **сохраненном режиме** *(retained mode)* графическая платформа хранит спецификацию сцены в виде графа сцены *(scene graph)*.

-   Объекты могут добавляться в граф сцены последовательно.
-   Каждое изменение графа приводит к перерисовке сцены

![](images/retained.png){width="100%"}

## Процедурный и декларативный подходы

::: columns
::: {.column width="50%"}
**Процедурный код** пишется на императивном языке программирования

-   Описывает *действия*
-   Стандарт при взаимодействии с графической платформой
-   В геоинформационных пакетах применяется на низком уровне, невидимом для пользователя
:::

::: {.column width="50%"}
**Декларативные спецификации** фиксируются на языке разметки

-   Описывают *результаты*
-   Вспомогательное средство в графических платформах
-   В геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)
:::
:::

## Отрисовка векторных объектов

-   Две основных операции: обводка и заливка
-   В случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.

Общий алгоритм для обводки:

1.  Установить тип отображаемого объекта
2.  Организовать обход по всем уровням вложенности с помощью цикла
3.  На самом низком уровне вложенности получить матрицу координат.
4.  Последовательно соединяя соседние координаты в матрице, отрисовать границу отрезками.

## Отрисовка отрезков

**Алгоритм Брезенхема \[**\@bresenham1965\]

`draw_line(x0, y0, x1, y1, image, color)`

![](images/bresenham.gif){width="55%"}

## Алгоритм Брезенхэма

Cистема экранных координат $XY$, где $X$ — столбец (увеличивается слева направо), $Y$ — строка (увеличивается сверху вниз)

-   $(x_0, y_0)$ — начальная точка отрезка в экранных координатах
-   $(x_1, y_1)$ — конечная точка отрезка в экранных координатах

Уравнение отрезка: $$\frac{y - y_0}{y_1-y_0} = \frac{x - x_0}{x_1-x_0}$$

Выразив $y$, получаем: $$y = \color{red}{\underbrace{\frac{y_1 - y_0}{x_1-x_0}}_{\textbf{d (уклон)}}} (x - x_0) + y_0$$

## Отрисовка отрезков

::: columns
::: {.column width="50%"}
*Стандартно* рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:

-   $x_0 \geq 0,~y_0 \geq 0$;
-   $x_0 < x_1,~y_0 \leq y_1$;
-   $x_1 - x_0 \geq y_1 - y_0$.
:::

::: {.column width="50%"}
![](images/coords.png){width="55%"}
:::
:::

## Алгоритм Брезенхэма

Для сектора `В-ЮВ` алгоритм опирается на координаты $x$:

::: columns
::: {.column width="50%"}
**Вычисляем заранее**:

-   $dx = x_1 - x_0$.
-   $dy = y_1 - y_0$.
-   $\color{blue}{d = dy / dx}$;
-   $\color{blue}{y = y_0}$;
-   $e = 0$
:::

::: {.column width="50%"}
**Для** $\color{blue}{x = x_0, ... x_1}$, **выполняем**:

1.  Рисуем пиксель $(x, y)$.
2.  Обновляем ошибку $e = e + |d|$.
3.  Если $e \geq 0.5$, то:

-   $\color{blue}{y = y + \texttt{sign}(dy)}$,
-   $e = e - 1$.
:::
:::

Использование функции $\texttt{sign}$ позволяет применять алгоритм также и для сектора `В-СВ` (только $y$ будет уменьшаться).

Обозначим этот случай как `draw_line_byX(x0, y0, x1, y1, image, color)`

## Алгоритм Брезенхэма

Для сектора `В-ЮВ` алгоритм опирается на координаты $x$:

::: columns
::: {.column width="50%"}
*Альтернативно* рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:

-   $x_0 \geq 0,~y_0 \geq 0$;
-   $x_0 \leq x_1,~y_0 < y_1$;
-   $x_1 - x_0 < y_1 - y_0$.
:::

::: {.column width="50%"}
![](images/coords2.png){width="55%"}
:::
:::

Использование функции $\texttt{sign}$ позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только $x$ будет уменьшаться).

Обозначим этот случай как `draw_line_byY(x0, y0, x1, y1, image, color)`

## Алгоритм Брезенхэма

Для оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на языке __Python__:
```{python, eval=FALSE}
def draw_line(x0, y0, x1, y1, image, color):
    if abs(y1 - y0) < abs(x1 - x0): # пологая линия
        if x0 > x1:
            draw_line_byX(x1, y1, x0, y0, image, color)
        else:
            draw_line_byX(x0, y0, x1, y1, image, color)
    else:
        if y0 > y1:                 # крутая линия
            draw_line_byY(x1, y1, x0, y0, image, color)
        else:
            draw_line_byY(x0, y0, x1, y1, image, color)
```

где `abs()` — функция вычисления модуля.

## Заливка полигона

![](images/polyfill.png){width="70%"}


## Библиография
