<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Введение в компьютерную графику</title>
    <meta charset="utf-8" />
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2020-10-06" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Введение в компьютерную графику
## Визуализация пространственных данных
### Тимофей Самсонов
### 2020-10-06

---




## Компьютерная графика

Наука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.

- Визуальный аспект: компьютер -&gt; человек
- Интерактивный аспект: человек -&gt; компьютер

![](01_CG_Fundamentals_insertimage_2.png)

---

## Мультидисциплинарность

- физика

- математика

- человеческое зрение

- человеко-машинное взимодействие

- программная и аппаратная инженерия

- графический дизайн

- ...

---

## Связь с компьютерным зрением

__Компьютерная графика__: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.

__Компьютерное зрение__: определение параметров сцены и погруженных в нее объектов при заданных допущениях.

![:scale 75%](01_CG_Fundamentals_insertimage_3.png)

.small[_Lesage, Visvalingam, 2002_]

---

## Графический конвейер

![:scale 85%](01_CG_Fundamentals_insertimage_4.png)

.small[_Hughes et al, 2013_]

---

## Графический конвейер

![:scale 80%](01_CG_Fundamentals_insertimage_5.png)

Взаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения

---

## Графический конвейер 2D-приложения

.pull-left[
  ![](01_CG_Fundamentals_insertimage_6.png)
]

.pull-right[
__Графическая платформа__ отвечает за взаимодействие приложения и оборудования

__Модель приложения__ (application model) представляет визуализируемые данные

__Клиентская область__ (client area) определяет пространство, в котором приложение выполняет отрисовку.

__Порт просмотра__ (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели
]

---

## Эволюция графической платформы

__1980-е — начало 1990-х__ _(Apple QuickDraw, Microsoft GDI)_: отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка .red[_примитивов_]: геометрических форм или битмапов (пиксельных карт). 
  - Точка `\((0,0)\)` располагается в левом верхнем углу.
  - Каждый примитив заполняется путем вызова определенной функции (например, `FillRectangle`).
  - Размер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.
  
__Середина 1990-х — н.вр.__ Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат.

---

## Непосредственный режим 

В .blue[__непосредственном режиме__] _(immediate mode)_ клиент через графическую платформу обращается непосредственно к выводящему устройству. 
- Запись примитивов, переданных приложением, не выполняется. 
- При смене сцены приложение должно перерисовать ее целиком. 

![](01_CG_Fundamentals_insertimage_8.png)

---

## Сохраненный режим 

В .red[__сохраненном режиме__] _(retained mode)_ графическая платформа хранит спецификацию сцены в виде специализированной базы данных, которая называется графом сцены _(scene graph)_. 
- Объекты могут добавляться в граф сцены последовательно.
- Каждое изменение графа приводит к перерисовке сцены

![](01_CG_Fundamentals_insertimage_7.png)

---

## Процедурный и декларативный подходы

.blue[__Процедурный код__] пишется на императивном языке программирования 
- Описывает _действия_
- Стандарт при взаимодействии с графической платформой 
- В геоинформационных пакетах применяется на низком уровне, невидимом для пользователя

.red[__Декларативные спецификации__] фиксируются на языке разметки
- Описывают _результаты_
- Вспомогательное средство в графических платформах
- В геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)

---

## Процедурный код

Классический низкоуровневый пример — отрисовка линии.

`draw_line(x0, y0, x1, y1)`

![:scale 70%](01_CG_Fundamentals_insertimage_9.gif)

.blue[__Алгоритм Брэзенхема__]
.small[_Bresenham, J. E._ (1965). "Algorithm for computer control of a digital plotter" (PDF). __IBM Systems Journal__. 4 (1): 25–30. doi:10.1147/sj.41.0025.]

---

## Алгоритм Брезенхэма

Cистема экранных координат `\(XY\)`, где `\(X\)` — столбец (увеличивается слева направо), `\(Y\)` — строка (увеличивается сверху вниз)

- `\((x_0, y_0)\)` — начальная точка отрезка в экранных координатах
- `\((x_1, y_1)\)` — конечная точка отрезка в экранных координатах

Уравнение отрезка:
`$$\frac{y - y_0}{y_1-y_0} = \frac{x - x_0}{x_1-x_0}$$`
Выразив `\(y\)`, получаем:
`$$y = \color{red}{\underbrace{\frac{y_1 - y_0}{x_1-x_0}}_{\textbf{d (уклон)}}} (x - x_0) + y_0$$`
---

## Алгоритм Брезенхэма

_Стандартно_ рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:
- `\(x_0 \geq 0,~y_0 \geq 0\)`;
- `\(x_0 &lt; x_1,~y_0 \leq y_1\)`;
- `\(x_1 - x_0 \geq y_1 - y_0\)`.
![:scale 70%](images/Coords.png)

---

## Алгоритм Брезенхэма

Для сектора `В-ЮВ` алгоритм опирается на координаты `\(x\)`:

.pull-left[__Вычисляем заранее__:
- `\(dx = x_1 - x_0\)`.
- `\(dy = y_1 - y_0\)`.
- `\(\color{blue}{d = dy / dx}\)`;
- `\(\color{blue}{y = y_0}\)`;
- `\(e = 0\)`]

.pull-right[__Для `\(\color{blue}{x = x_0, ... x_1}\)`, выполняем__:
1. Рисуем пиксель `\((x, y)\)`.
2. Обновляем ошибку `\(e = e + |d|\)`.
3. Если `\(e \geq 0.5\)`, то:
  - `\(\color{blue}{y = y + \texttt{sign}(dy)}\)`,
  - `\(e = e - 1\)`.]
  
Использование функции `\(\texttt{sign}\)` позволяет применять алгоритм также и для сектора `В-СВ` (только `\(y\)` будет уменьшаться).

Обозначим этот случай как `draw_line_byX(x0, y0, x1, y1)`

---

## Алгоритм Брезенхэма

.pull-left[_Альтернативно_ рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:
- `\(x_0 \geq 0,~y_0 \geq 0\)`;
- `\(x_0 \leq x_1,~y_0 &lt; y_1\)`;
- `\(x_1 - x_0 &lt; y_1 - y_0\)`.]

.pull-right[![:scale 70%](images/Coords2.png)]

---

## Алгоритм Брезенхэма

Для сектора `Ю-ЮВ` алгоритм опирается на координаты `\(y\)`:

.pull-left[__Вычисляем заранее__:
- `\(dx = x_1 - x_0\)`.
- `\(dy = y_1 - y_0\)`.
- `\(\color{red}{d = dx / dy}\)`;
- `\(\color{red}{x = x_0}\)`;
- `\(e = 0\)`]

.pull-right[__Для `\(\color{red}{y = y_0, ... y_1}\)`, выполняем__:
1. Рисуем пиксель `\((x, y)\)`.
2. Обновляем ошибку `\(e = e + |d|\)`.
3. Если `\(e \geq 0.5\)`, то:
  - `\(\color{red}{x = x + \texttt{sign}(dx)}\)`,
  - `\(e = e - 1\)`.]
  
Использование функции `\(\texttt{sign}\)` позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только `\(x\)` будет уменьшаться).

Обозначим этот случай как `draw_line_byY(x0, y0, x1, y1)`

---

## Алгоритм Брезенхэма

Для оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на языке __Python__:

```python
def plot_line(x0, y0, x1, y1):
    if abs(y1 - y0) &lt; abs(x1 - x0): # пологая линия
        if x0 &gt; x1:
            plot_line_byX(x1, y1, x0, y0)
        else:
            plot_line_byX(x0, y0, x1, y1)
    else:
        if y0 &gt; y1:                 # крутая линия
            plot_line_byY(x1, y1, x0, y0)
        else:
            plot_line_byY(x0, y0, x1, y1)
```

где `abs()` — функция вычисления модуля.

---

## Заливка полигона
![:scale 95%](images/polyfill.png)

---

## Заливка полигона

.blue[__Алгоритм сканирующей линии:__]

Для каждого `\(y_k = y_{min},...,y_{max}\)` необходимо получить упорядоченное по возрастанию множество `\(X = \{x_1, x_2, ..., x_n\}\)` абсцисс точек его пересечения с исходными линиями:
1. Для каждой линии `\(l_j, j = 1,...,N\)`:
  - вычислить флаг пересечения `\(f: y^j_0 &lt; y_k \neq y^j_1 &lt; y_k\)`;
  - если `\(f = \texttt{TRUE}\)`, то
      - вычислить `\(x^j = x^j_0 + (x^j_1 - x^j_0)\frac{y_k - y^j_0}{y^j_1 - y^j_0}\)`;
      - добавить `\(x^j\)` в множество `\(X\)`.
2. Если `\(X\)` не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:

`$$\lceil x_1 \rceil \to \lfloor x_2 \rfloor,~\lceil x_3 \rceil \to \lfloor x_4 \rfloor,~...~,~\lceil x_{n-1} \rceil \to \lfloor x_n \rfloor$$`

---

## Передискретизация (resampling)

Передискретизация необходима при визуализации растрового изображения на растровом экране. Как правило, разрешение этих растров не совпадает.

![:scale 65%](images/res_screen.png)

---

## Метод ближайшего соседа

Используется значение ближайшего пикселя:

![:scale 70%](images/res_nn.png)

---

## Метод билинейной интерполяции

Восстанавливается поверхность в ячейке из 4 узлов:

![:scale 75%](images/res_bln.png)
---

## Метод билинейной интерполяции

.left-40[
  ![:scale 85%](images/res_bln_crop.png)
]

.right-60[
Коэффициенты определяются по 4 точкам:
`$$\begin{cases}
a_{00} = f_{00},\\
a_{10} = f_{10} - f_{00},\\
a_{01} = f_{01} - f_{00},\\
a_{01} = f_{00} + f_{11} - f_{10} - f_{01}.
\end{cases}$$`

`$$f(x, y) = a_{00} + a_{10}x + a_{01}y + a_{11}xy$$`]


Координаты `\(x\)` и `\(y\)` меняются в диапазоне от `\(0\)` до `\(1\)` в пределах ячейки.

---

## Метод бикубической интерполяции

Восстанавливается поверхность в 9 ячейках, окружающих узел:

![:scale 75%](images/res_bcb.png)

---

## Метод бикубической интерполяции

.left-40[
![:scale 95%](images/res_bcb_crop.png)
]

.right-60[
Коэффициенты определяются по 16 точкам:

`$$\begin{cases}
f(0,0) = a_{00},\\
f(1,0) = a_{00} + a_{10} + a_{20} + a_{30},\\
f(0,1) = a_{00} + a_{01} + a_{02} + a_{03},\\
f(1,1) = \sum_{i=0}^3 \sum_{j=0}^3 a_{ij},\\
\dots
\end{cases}$$`

`$$f(x, y) = \sum_{i=0}^3 \sum_{j=0}^3 a_{ij} x^i y^j$$` 
]

Координаты `\(x\)` и `\(y\)` меняются в диапазоне от `\(0\)` до `\(1\)` в пределах окрестности `\(3 \times 3\)` ячеек.

---

## Передискретизация и фильтрация

.pull-left[
![:scale 90%](01_CG_Fundamentals_insertimage_10.png)
.small[_Marschner et al., 2016_]
]
.pull-right[
Передискретизацию можно также рассматривать как двухстадийный процесс:
- Построение гладкой непрерывной функции путем применения реконструкционного фильтра

- Выборка (семплирование) значений функции в локациях, определенных узлами новой сетки
]

---

## Передискретизация и фильтрация

Псевдокод одномерной передискретизации:


```python
fun resample(sequence a, float x0, float dx, int n, filter f)
  b = list(length = n)
  for i = 0 to n-1 do
    b[i] = reconstruct(a, f, x0 + i * dx)
  return b
```

Параметр `x0` отвечает за расположение первого элемента выборки в системе координат исходной последовательности.

Например, если этот элемент расположен посередине между 0-м и 1-м элементом исходной последовательности, то `x0 = 0.5`

---

## Передискретизация и фильтрация

Проблема передискретизации при даунсемплинге (понижении разрешения) заключается в появлении артефактов таких как муар (слева) и зубчатость (справа):

![](01_CG_Fundamentals_insertimage_12.png)
.small[_Marschner et al., 2016_]

Поэтому при понижени разрешения помимо реконструкционного фильтра необходимо использовать также сглаживающий.

---

## Передискретизационный фильтр

Поскольку свёрточные фильтры можно перемножать, для комбинирования реконструкции и сглаживания достаточно провести фильтрацию один раз (диагональная стрелка):

![:scale 65%](01_CG_Fundamentals_insertimage_11.png)

.small[_Marschner et al., 2016_]

---

## Метод бикубической интерполяции

Для достижения бикубической интерполяции коэффициенты необходимо рассчитать для каждой ячейки исходного растра. Keys (1981) показал, что аналогичного результата можно достичь путем свёртки с использованием следующего фильтра:

`$$W(x) = \begin{cases}
 (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{для } |x| \leq 1, \\
 a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{для } 1 &lt; |x| &lt; 2, \\
 0                       &amp; \text{иначе},
\end{cases},$$`

где `\(a = -0.5\)` или `\(a = -0.75\)`.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
