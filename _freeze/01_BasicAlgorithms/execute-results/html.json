{
  "hash": "f8780564c1f1c650cf88e4d8caacd00c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Основы компьютерной графики\nsubtitle: Визуализация пространственных данных\ndate: today\ndate-format: long\nauthor: Самсонов Тимофей Евгеньевич\nexecute:\n  echo: false\n  freeze: true\nformat:\n  revealjs:\n    theme:\n      - default\n      - custom.scss\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: 'Самсонов Т. Е. Визуализация пространственных данных: курс лекций'\n    header-includes: '<link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>'\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n## Компьютерная графика\n\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\n-   Визуальный аспект: компьютер → человек\n-   Интерактивный аспект: человек → компьютер\n\n![](images/people.png){width=\"100%\"}\n\n## Связь с компьютерным зрением\n\n**Компьютерная графика**: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\n\n**Компьютерное зрение**: определение параметров сцены и погруженных в нее объектов при заданных допущениях.\n\n![](images/sketch.png){width=\"75%\"}\n\n## Аффинные преобразования\n\n**Аффинное преобразование** $f\\colon\\mathbb{R}^{n}\\to \\mathbb{R}^{n}$ есть преобразование вида:\n\n$$\nf(\\mathrm p) = \\mathbf M \\cdot \\mathrm p + \\mathrm v\n$$\n\nгде $\\mathbf M$ --- *обратимая матрица* (квадратная матрица, определитель которой отличен от нуля) и $v\\in \\mathbb{R}^{n}$.\n\n$\\mathbf M$ и $\\mathrm v$ обычно объединяются в одну матрицу $\\mathbf A$, что требует представления $p$ в *однородных* координатах: $\\widehat{\\mathrm p} = (x_p, y_p,..., 1)$. В этом случае аффинное преобразование можно записать как:\n\n$$\nf(\\mathrm p) = \\mathbf A \\cdot \\widehat{\\mathrm p} = \\left[ \\begin{array}{ccc|c} \\, & \\mathbf M & & \\mathrm v \\ \\\\ 0 & \\ldots & 0 & 1 \\end{array} \\right] \\begin{bmatrix} \\mathrm p \\\\ 1 \\end{bmatrix}\n$$\n\n## Аффинные преобразования\n\n**Сдвиг** на вектор трансляции $t = (t_x, t_y)$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} 1 &  0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf T(t_x, t_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1x + 0y + t_x1 \\\\ 0x + 1y + t_y1 \\\\ 0x + 0y + 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix},\n$$\n\n**Поворот** на угол $\\theta$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 0 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} \\cos \\theta &  -\\sin \\theta & 0 \\\\ \\sin \\theta & \\cos \\theta  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf R(\\theta)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta \\\\ x \\sin \\theta + y \\cos \\theta \\\\ 1 \\end{bmatrix},\n$$\n\n## Аффинные преобразования\n\n**Масштабирование** с коэффициентами $s_x, s_y$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} s_x &  0 & 0 \\\\ 0 & s_y  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf S(s_x, s_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x s_x \\\\ y s_y \\\\ 1 \\end{bmatrix},\n$$\n\n-   при навигации по карте $s_x = s_y = a$\n-   для зеркального отражения по соответствующим осям $s_x$ или $s_y$ будут иметь отрицательные значения.\n\n## Стандартные сценарии\n\nПри загрузке слоя данных в пустой проект объекты вписываются в порт просмотра.\n\nПусть ограничивающий прямоугольник (*экстент*) данных имеет размеры $[x_0, y_0]\\times[x_1, y_1]$, а размер порта просмотра $[0, di]\\times[0, dj]$. Тогде необходимо выполнить следующие преобразования:\n\n-   Совместить начало координат с центром экстента данных — точкой $[(x_1 + x_0)/2, (y_1 + y_0)/2]$.\n\n-   На оcнове сравнения пропорций экстента $\\frac{dy}{dx}$ и порта просмотра $\\frac{di}{dj}$ выбрать коэффициент масштабирования $s$:\n\n$$s = \\begin{cases}\n\\frac{dj}{dx},~\\texttt{если}~\\frac{dy}{dx} \\leq \\frac{di}{dj}\\\\\n\\frac{di}{dy},~\\texttt{если}~\\frac{dy}{dx} > \\frac{di}{dj}\\\\\n\\end{cases}$$\n\n## Стандартные сценарии\n\n-   Отмасштабировать координаты на полученный коэффициент $s$.\n\n-   Переместить отмасштабированное изображение в точку $(di/2, dj/2)$.\n\nИтоговая матрица преобразования $\\textbf{A}$ будет выглядеть следующим образом:\n\n$$\\textbf A = \\textbf T(di/2, dj/2)~\\textbf S(s)~\\textbf T(-(x_1 + x_0)/2, -(y_1 + y_0)/2)$$\n\nТочки исходных объектов $p$ будут трансформированы в точки внутри порта просмотра $p'$ как:\n\n$$p' = \\textbf A p$$\n\n## Стандартные сценарии\n\nПусть текущая матрица отображения равна $A$. Пользователь:\n\n-   перетащил изображение из точки $(i_1, j_1)$ в точку $(i_2, j_2)$:\n\n$$\\mathbf A = \\mathbf T(i_2-i_1, j_2 - j_1)\\mathbf A$$\n\n-   в точке $(i, j)$ прокрутил колесико мыши на $k > 0$ оборота:\n\n$$\\mathbf A = \\mathbf T(i, j)~\\mathbf S(ks, ks)~\\mathbf T(-i, -j)~\\mathbf A$$\n\n-   в точке $(i, j)$ прокрутил колесико мыши на $k < 0$ оборота:\n\n$$\\mathbf A = \\mathbf T(i, j)~\\mathbf S(-\\frac{1}{ks}, -\\frac{1}{ks})~\\mathbf T(-i, -j)~\\mathbf A$$\n\nКаждый оборот соответствует изменению масштаба в $s$ раз.\n\n## Отсечение отрезков\n\nОдин из самых широко используемых — **алгоритм Коэна-Сазерленда**, в котором используется разбиение плоскости на 9 частей прямыми, координаты которых определяются границами прямоугольника (в частности — порта просмотра):\n\n::: columns\n::: {.column width=\"50%\"}\n![](images/cohen_sutherland.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n-   `INSIDE = 0` — $0000$\n-   `LEFT = 1` — $0001$\n-   `RIGHT = 2` — $0010$\n-   `BOTTOM = 4` — $0100$\n-   `TOP = 8` — $1000$\n\nОтрезки, обе точки которых находятся по одну сторону от прямоугольника, имеют совпадающий единичный бит в одной и той же позиции\n:::\n:::\n\n## Вычисление кодов Коэна-Сазерленда\n\nПусть дана точка $(i, j)$, а также границы порта просмотра $(i_{min}, i_{max})$, $(j_{min}, j_{max})$.\n\nТогда код вычисляется следующим образом:\n\n```         \ndef code(i, j, imax, jmax):\n    code = INSIDE\n    if j < jmin:\n        code |= LEFT\n    elif j > jmax:\n        code |= RIGHT\n    if i < imin:\n        code |= TOP\n    elif i > imax:\n        code |= BOTTOM\n    return code\n```\n\nВ данном случае применяется операция *логическое ИЛИ*, которая устанавливает в каждый бит $1$, если хотя бы у одного из операндов соответствующий бит равен $1$.\n\n## Алгоритм Коэна-Сазерленда\n\nДля каждого отрезка $(i_0, j_0), (i_1, j_1)$ выполняется бесконечный цикл, внутри которого ведутся следующие действия:\n\n1.  Вычисляются коды `code0` и `code1` для концов отрезка.\n\n2.  Если оба конца находятся внутри порта просмотра (`code0 | code1 == 0`), то отрезок принимается целиком и цикл прерывается.\n\n3.  Если оба конца находятся по одну сторону от порта просмотра (`code0 & code1 != 0`), то отрезок отклоняется целиком и цикл прерывается.\n\n4.  В противном случае (оба конца находятся по разные стороны от порта просмотра), выполняются следующие действия:\n\n    -   Выбирается любая точка, находящаяся за пределами порта просмотра.\n    -   Выполняется пересечение отрезка с прямой, определяющей ту сторону, в которой находится выбранная точка.\n    -   Выбранная точка заменяется на найденное пересечение.\n\n## Отрисовка объектов\n\n-   Выполняется после отсечения\n-   Две основных операции: обводка и заливка\n-   В случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\n**Общий алгоритм для обводки:**\n\n1.  Установить тип отображаемого объекта\n2.  Организовать обход по всем уровням вложенности с помощью цикла\n3.  На самом низком уровне вложенности получить матрицу координат.\n4.  Последовательно соединяя соседние координаты в матрице, отрисовать границу отрезками.\n\n## Отрисовка отрезков\n\n**Алгоритм Брезенхема** [@bresenham1965]\n\n`draw_line(i0, j0, i1, j1, image, color)`\n\n![](images/bresenham.gif){width=\"55%\"}\n\n## Алгоритм Брезенхэма\n\nCистема экранных координат $ij$, где $i$ — строка (увеличивается сверху вниз), $j$ — столбец (увеличивается слева направо),\n\n-   $(i_0, j_0)$ — начальная точка отрезка в экранных координатах\n-   $(i_1, j_1)$ — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: $$\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}$$\n\nВыразив $i$, получаем: $$i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0$$\n\n## Отрисовка отрезков\n\n::: columns\n::: {.column width=\"40%\"}\n*Стандартно* рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 < j_1,~i_0 \\leq i_1$;\n-   $j_1 - j_0 \\geq i_1 - i_0$.\n:::\n\n::: {.column width=\"60%\"}\n![](images/coords.png){width=\"100%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `В-ЮВ` алгоритм опирается на координаты $x$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n-   $dj = j_1 - j_0$.\n-   $di = i_1 - i_0$.\n-   $\\color{blue}{d = di / dj}$;\n-   $\\color{blue}{i = i_0}$;\n-   $e = 0$\n:::\n\n::: {.column width=\"50%\"}\n**Для** $\\color{blue}{j = j_0, ... j_1}$, **выполняем**:\n\n1.  Рисуем пиксель $(i, j)$.\n2.  Обновляем ошибку $e = e + |d|$.\n3.  Если $e \\geq 0.5$, то:\n\n-   $\\color{blue}{i = i + \\texttt{sign}(di)}$,\n-   $e = e - 1$.\n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `В-СВ` (только $i$ будет уменьшаться).\n\nОбозначим случай `draw_line_byJ(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\n::: columns\n::: {.column width=\"50%\"}\n*Альтернативно* рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 \\leq j_1,~i_0 < i_1$;\n-   $j_1 - j_0 < i_1 - i_0$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/coords2.png){width=\"55%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `Ю-ЮВ` алгоритм опирается на координаты $i$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n-   $dj = j_1 - j_0$.\n-   $di = i_1 - i_0$.\n-   $\\color{red}{d = dj / di}$;\n-   $\\color{red}{j = j_0}$;\n-   $e = 0$\n:::\n\n::: {.column width=\"50%\"}\n**Для** $\\color{red}{i = i_0, ... i_1}$ **выполняем**:\n\n1.  Рисуем пиксель $(i, j)$.\n2.  Обновляем ошибку $e = e + |d|$.\n3.  Если $e \\geq 0.5$, то:\n\n-   $\\color{red}{j = j + \\texttt{sign}(dj)}$,\n-   $e = e - 1$.\n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только $j$ будет уменьшаться).\n\nОбозначим случай `draw_line_byI(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на **Python**:\n\n```         \ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) < abs(j1 - j0): # пологая линия\n        if j0 > j1:\n            draw_line_byJ(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byJ(i0, j0, i1, j1, image, color)\n    else:\n        if i0 > i1:                 # крутая линия\n            draw_line_byI(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byI(i0, j0, i1, j1, image, color)\n```\n\nгде `abs()` — функция вычисления модуля.\n\n## Заливка полигона\n\n![](images/filling.png){width=\"70%\"}\n\n## Алгоритм сканирующей линии\n\nДля каждого $i_k = i_{min},...,i_{max}$ получить упорядоченное по возрастанию множество $J = \\{j_0, j_1, ..., j_{n-1}\\}$ столбцов пересечений с исходными линиями:\n\n1.  Для каждой линии $l_m, m = 0,...,N-1$:\n\n-   вычислить флаг пересечения $f: i^m_0 > i_k \\neq i^m_1 > i_k$;\n-   если $f = \\texttt{TRUE}$, то\n    -   вычислить $j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}$;\n    -   добавить $j^m$ в множество $J$.\n\n2.  Если $J$ не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n$$\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor$$\n\n## Передискретизация (resampling)\n\n**Передискретизация** — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\n![Исходное изображение](images/clipboard-2394961780.png){fig-align=\"left\"}\n\n## Передискретизация (resampling)\n\n**Передискретизация** — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\n![Ближайший сосед (укрупнение пикселя)](images/clipboard-2530888533.png){fig-align=\"left\"}\n\n## Передискретизация (resampling)\n\n**Передискретизация** — изменение частоты дискретизации. Нужна при визуали-зации растров, если размер ячейки не соответствует размеру пикселя монитора.\n\n![Билинейная интерполяция (уменьшение пикселя)](images/clipboard-3824530245.png){fig-align=\"left\"}\n\n## Передискретизация (resampling)\n\nПередискретизация необходима при визуализации растрового изображения на растровом экране. Как правило, разрешение этих растров не совпадает.\n\n![](images/res_screen.png){width=\"50%\"}\n\n## Метод ближайшего соседа\n\nИспользуется значение ближайшего пикселя:\n\n![](images/res_nn.png){width=\"50%\"}\n\n## Метод билинейной интерполяции\n\nВосстанавливается поверхность в ячейке из 4 узлов:\n\n![](images/res_bln.png){width=\"50%\"}\n\n## Метод билинейной интерполяции\n\n::: columns\n::: {.column width=\"50%\"}\n![](images/res_bln_crop.png)\n:::\n\n::: {.column width=\"50%\"}\nКоэффициенты определяются по 4 точкам:\n\n$$\\begin{cases}\na_{00} = f_{00},\\\\\na_{10} = f_{10} - f_{00},\\\\\na_{01} = f_{01} - f_{00},\\\\\na_{01} = f_{00} + f_{11} - f_{10} - f_{01}.\n\\end{cases}$$\n\n$$f(x, y) = a_{00} + a_{10}x + a_{01}y + a_{11}xy$$\n\nКоординаты $x$ и $y$ меняются в диапазоне от $0$ до $1$ в пределах ячейки.\n:::\n:::\n\n## Метод бикубической интерполяции\n\nВосстанавливается поверхность в 9 ячейках, окружающих узел:\n\n![](images/res_bcb.png){width=\"55%\"}\n\n## Метод бикубической интерполяции\n\n::: columns\n::: {.column width=\"50%\"}\n![](images/res_bcb_crop.png)\n:::\n\n::: {.column width=\"50%\"}\nКоэффициенты определяются по 16 точкам:\n\n$$\\begin{cases}\nf(0,0) = a_{00},\\\\\nf(1,0) = a_{00} + a_{10} + a_{20} + a_{30},\\\\\nf(0,1) = a_{00} + a_{01} + a_{02} + a_{03},\\\\\nf(1,1) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij},\\\\\n\\dots\n\\end{cases}$$\n\n$$f(x, y) = \\sum_{i=0}^3 \\sum_{j=0}^3 a_{ij} x^i y^j$$\n\nКоординаты $x$ и $y$ меняются в диапазоне от $0$ до $1$ в пределах окрестности $3 \\times 3$ ячеек.\n:::\n:::\n\n## Сглаживание (antialiasing)\n\nПри крупном размере пиксела выводящего устройства ступенчатость линий и границ полигонов становится заметной.\n\nДля устранения эффекта ступенчатости используется **сглаживание** (*antialiasing*).\n\n![](images/antialiasing.png)\n\n## Сглаживание (antialiasing)\n\n![](images/aa_settings.jpg)\n\n## Суперсемплинг (antialiasing)\n\nПусть результирующее растровое изображение $R$ имеет размеры $m \\times n$.\n\n1.  Создается буферное изображение $R_b$ размером $km \\times kn$, где $k \\in \\mathbb{N^*}$ — коэффициент сглаживания (положительное натуральное число).\n2.  Объекты отрисовываются в $R_b$.\n3.  Производится передискретизация $R_b \\to R$ с использованием блочной фильтрации (*box filter*). Значение результирующего пиксела $R[i, j]$ равняется среднему арифметическому значений $R_b$, попадающих в его пределы:\n\n$$R[i, j] = \\sum_{l = 1}^L s(R_b) / L,$$\n\nгде $s(R_b)$ — выборочное значение (сэмпл), взятое с $R_b$, $L$ — количество сэмплов\n\n## Суперсемплинг (antialiasing)\n\n::: columns\n::: {.column width=\"50%\"}\nБез сглаживания\n\n![](images/clipboard-3254345689.png){fig-align=\"left\"}\n:::\n\n::: {.column width=\"50%\"}\nСо сглаживанием\n\n![](images/clipboard-3877073781.png){fig-align=\"left\"}\n:::\n:::\n\n## Библиография\n\n",
    "supporting": [
      "01_BasicAlgorithms_files"
    ],
    "filters": [],
    "includes": {}
  }
}