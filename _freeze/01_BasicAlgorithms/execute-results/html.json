{
  "hash": "5fc71b83b37c71f334f76331509c380a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Основы компьютерной графики\nsubtitle: Визуализация пространственных данных\ndate: today\ndate-format: long\nauthor: Самсонов Тимофей Евгеньевич\nexecute:\n  echo: false\n  freeze: true\nformat:\n  revealjs:\n    theme:\n      - default\n      - custom.scss\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: 'Самсонов Т. Е. Визуализация пространственных данных: курс лекций'\n    header-includes: '<link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>'\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n## Компьютерная графика\n\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\n-   Визуальный аспект: компьютер → человек\n-   Интерактивный аспект: человек → компьютер\n\n![](images/people.png){width=\"100%\"}\n\n## Связь с компьютерным зрением\n\n**Компьютерная графика**: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\n\n**Компьютерное зрение**: определение параметров сцены и погруженных в нее объектов при заданных допущениях.\n\n![](images/sketch.png){width=\"75%\"}\n\n\\[Lesage, Visvalingam, 2002\\]\n\n## Графический конвейер\n\n![](images/conveyor1.png){width=\"80%\"}\n\nВ статичной сцене графический конвейер определяет последовательность отрисовки изображения.\n\n## Графический конвейер\n\n![](images/conveyor2.png){width=\"65%\"}\n\nВзаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения\n\n## Структура 2D-приложения\n\n::: columns\n::: {.column width=\"40%\"}\n![](images/2D_app.png){width=\"100%\"}\n:::\n\n::: {.column width=\"60%\"}\n-   **Графическая платформа** отвечает за взаимодействие приложения и оборудования\n\n-   **Модель приложения** (application model) представляет визуализируемые данные\n\n-   **Клиентская область** (client area) определяет пространство, в котором приложение выполняет отрисовку.\n\n-   **Порт просмотра** (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели\n:::\n:::\n\n## Эволюция графической платформы\n\n**1980-е — начало 1990-х** *(Apple QuickDraw, Microsoft GDI)*: отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка *примитивов*: геометрических форм или битмапов (пиксельных карт).\n\n-   Каждый примитив заполняется путем вызова определенной функции (например, `FillRectangle`).\n-   Размер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.\n\n**Середина 1990-х — н.вр.** Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат.\n\n## Непосредственный режим\n\nВ **непосредственном режиме** *(immediate mode)* клиент через графическую платформу обращается непосредственно к выводящему устройству.\n\n-   Запись примитивов, переданных приложением, не выполняется.\n-   При смене сцены приложение должно перерисовать ее целиком.\n\n![](images/immediate.png){width=\"100%\"}\n\n## Сохраненный режим\n\nВ **сохраненном режиме** *(retained mode)* графическая платформа хранит спецификацию сцены в виде графа сцены *(scene graph)*.\n\n-   Объекты могут добавляться в граф сцены последовательно.\n-   Каждое изменение графа приводит к перерисовке сцены\n\n![](images/retained.png){width=\"100%\"}\n\n## Процедурный и декларативный подходы\n\n::: columns\n::: {.column width=\"50%\"}\n**Процедурный код** пишется на императивном языке программирования\n\n-   Описывает *действия*\n-   Стандарт при взаимодействии с графической платформой\n-   В геоинформационных пакетах применяется на низком уровне, невидимом для пользователя\n:::\n\n::: {.column width=\"50%\"}\n**Декларативные спецификации** фиксируются на языке разметки\n\n-   Описывают *результаты*\n-   Вспомогательное средство в графических платформах\n-   В геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)\n:::\n:::\n\n## Отрисовка векторных объектов\n\n-   Две основных операции: обводка и заливка\n-   В случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\n1.  Установить тип отображаемого объекта\n2.  Организовать обход по всем уровням вложенности с помощью цикла\n3.  На самом низком уровне вложенности получить матрицу координат.\n4.  Последовательно соединяя соседние координаты в матрице, отрисовать границу отрезками.\n\n## Отрисовка отрезков\n\n**Алгоритм Брезенхема** [@bresenham1965]\n\n`draw_line(i0, j0, i1, j1, image, color)`\n\n![](images/bresenham.gif){width=\"55%\"}\n\n## Алгоритм Брезенхэма\n\nCистема экранных координат $ij$, где $i$ — строка (увеличивается сверху вниз), $j$ — столбец (увеличивается слева направо),\n\n-   $(i_0, j_0)$ — начальная точка отрезка в экранных координатах\n-   $(i_1, j_1)$ — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: $$\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}$$\n\nВыразив $i$, получаем: $$i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0$$\n\n## Отрисовка отрезков\n\n::: columns\n::: {.column width=\"40%\"}\n*Стандартно* рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 < j_1,~i_0 \\leq i_1$;\n-   $j_1 - j_0 \\geq i_1 - i_0$.\n:::\n\n::: {.column width=\"60%\"}\n![](images/coords.png){width=\"100%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `В-ЮВ` алгоритм опирается на координаты $x$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n-   $dj = j_1 - j_0$.\n-   $di = i_1 - i_0$.\n-   $\\color{blue}{d = di / dj}$;\n-   $\\color{blue}{i = i_0}$;\n-   $e = 0$\n:::\n\n::: {.column width=\"50%\"}\n**Для** $\\color{blue}{j = j_0, ... j_1}$, **выполняем**:\n\n1.  Рисуем пиксель $(i, j)$.\n2.  Обновляем ошибку $e = e + |d|$.\n3.  Если $e \\geq 0.5$, то:\n\n-   $\\color{blue}{i = i + \\texttt{sign}(di)}$,\n-   $e = e - 1$.\n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `В-СВ` (только $i$ будет уменьшаться).\n\nОбозначим случай `draw_line_byJ(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\n::: columns\n::: {.column width=\"50%\"}\n*Альтернативно* рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 \\leq j_1,~i_0 < i_1$;\n-   $j_1 - j_0 < i_1 - i_0$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/coords2.png){width=\"55%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `Ю-ЮВ` алгоритм опирается на координаты $i$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n- $dj = j_1 - j_0$.\n- $di = i_1 - i_0$.\n- $\\color{red}{d = dj / di}$;\n- $\\color{red}{j = j_0}$;\n- $e = 0$\n\n:::\n\n::: {.column width=\"50%\"}\n__Для__ $\\color{red}{i = i_0, ... i_1}$ __выполняем__:\n\n1. Рисуем пиксель $(i, j)$.\n2. Обновляем ошибку $e = e + |d|$.\n3. Если $e \\geq 0.5$, то:\n  - $\\color{red}{j = j + \\texttt{sign}(dj)}$,\n  - $e = e - 1$.\n  \n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только $j$ будет уменьшаться).\n\nОбозначим случай `draw_line_byI(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на **Python**:\n\n```         \ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) < abs(j1 - j0): # пологая линия\n        if j0 > j1:\n            draw_line_byX(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byX(i0, j0, i1, j1, image, color)\n    else:\n        if i0 > i1:                 # крутая линия\n            draw_line_byY(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byY(i0, j0, i1, j1, image, color)\n```\n\nгде `abs()` — функция вычисления модуля.\n\n## Заливка полигона\n\n![](images/polyfill.png){width=\"70%\"}\n\n## Алгоритм сканирующей линии\n\nДля каждого $i_k = i_{min},...,i_{max}$ получить упорядоченное по возрастанию множество $J = \\{j_0, j_1, ..., j_{n-1}\\}$ столбцов пересечений с исходными линиями:\n\n1.  Для каждой линии $l_m, m = 0,...,N-1$:\n\n-   вычислить флаг пересечения $f: i^m_0 > i_k \\neq i^m_1 > i_k$;\n-   если $f = \\texttt{TRUE}$, то\n    -   вычислить $j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}$;\n    -   добавить $j^m$ в множество $J$.\n\n2.  Если $J$ не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n$$\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor$$\n\n## Библиография\n\n",
    "supporting": [
      "01_BasicAlgorithms_files"
    ],
    "filters": [],
    "includes": {}
  }
}