{
  "hash": "9aeded596a80dbbeed456b12ff439cc9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Основы компьютерной графики\nsubtitle: Визуализация пространственных данных\ndate: today\ndate-format: long\nauthor: Самсонов Тимофей Евгеньевич\nexecute:\n  echo: false\n  freeze: true\nformat:\n  revealjs:\n    theme:\n      - default\n      - custom.scss\n    margin: 0.2\n    width: 1280\n    height: 720\n    slide-number: true\n    footer: 'Самсонов Т. Е. Визуализация пространственных данных: курс лекций'\n    header-includes: '<link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/pt-sans\" type=\"text/css\"/>'\nbibliography: references.yaml\nmainfont: PT Sans\n---\n\n## Компьютерная графика\n\nНаука и искусство визуальной коммуникации посредством компьютерного дисплея и инструментом интерактивного взаимодействия с ним.\n\n-   Визуальный аспект: компьютер → человек\n-   Интерактивный аспект: человек → компьютер\n\n![](images/people.png){width=\"100%\"}\n\n## Связь с компьютерным зрением\n\n**Компьютерная графика**: реализация с определенного ракурса внешнего вида сцены, в которую погружены модели объектов под заданными условиями освещения.\n\n**Компьютерное зрение**: определение параметров сцены и погруженных в нее объектов при заданных допущениях.\n\n![](images/sketch.png){width=\"75%\"}\n\n\\[Lesage, Visvalingam, 2002\\]\n\n## Графический конвейер\n\n![](images/conveyor1.png){width=\"80%\"}\n\nВ статичной сцене графический конвейер определяет последовательность отрисовки изображения.\n\n## Графический конвейер\n\n![](images/conveyor2.png){width=\"65%\"}\n\nВзаимодействие с пользователем может оказывать влияние на последующее поведение графического приложения\n\n## Структура 2D-приложения\n\n::: columns\n::: {.column width=\"40%\"}\n![](images/2D_app.png){width=\"100%\"}\n:::\n\n::: {.column width=\"60%\"}\n-   **Графическая платформа** отвечает за взаимодействие приложения и оборудования\n\n-   **Модель приложения** (application model) представляет визуализируемые данные\n\n-   **Клиентская область** (client area) определяет пространство, в котором приложение выполняет отрисовку.\n\n-   **Порт просмотра** (viewport) определяет часть клиентской области, где генератор сцены выполняет отрисовку модели\n:::\n:::\n\n## Эволюция графической платформы\n\n**1980-е — начало 1990-х** *(Apple QuickDraw, Microsoft GDI)*: отрисовка пикселей на прямоугольной канве в целочисленных координатах. Отрисовка *примитивов*: геометрических форм или битмапов (пиксельных карт).\n\n-   Каждый примитив заполняется путем вызова определенной функции (например, `FillRectangle`).\n-   Размер объекта зависит от разрешения объекта. Более низкое разрешение (крупные пикселы) — больше размеры объектов.\n\n**Середина 1990-х — н.вр.** Переход к координатам с плавающей точкой позволил решить проблему зависимости размера изображения от системы координат.\n\n## Непосредственный режим\n\nВ **непосредственном режиме** *(immediate mode)* клиент через графическую платформу обращается непосредственно к выводящему устройству.\n\n-   Запись примитивов, переданных приложением, не выполняется.\n-   При смене сцены приложение должно перерисовать ее целиком.\n\n![](images/immediate.png){width=\"100%\"}\n\n## Сохраненный режим\n\nВ **сохраненном режиме** *(retained mode)* графическая платформа хранит спецификацию сцены в виде графа сцены *(scene graph)*.\n\n-   Объекты могут добавляться в граф сцены последовательно.\n-   Каждое изменение графа приводит к перерисовке сцены\n\n![](images/retained.png){width=\"100%\"}\n\n## Процедурный и декларативный подходы\n\n::: columns\n::: {.column width=\"50%\"}\n**Процедурный код** пишется на императивном языке программирования\n\n-   Описывает *действия*\n-   Стандарт при взаимодействии с графической платформой\n-   В геоинформационных пакетах применяется на низком уровне, невидимом для пользователя\n:::\n\n::: {.column width=\"50%\"}\n**Декларативные спецификации** фиксируются на языке разметки\n\n-   Описывают *результаты*\n-   Вспомогательное средство в графических платформах\n-   В геоинформационных пакетах применяется на высоком уровне при описании стилей карт (CSS, LYR, QML, SLD, YSLD)\n:::\n:::\n\n## Отрисовка векторных объектов\n\n-   Две основных операции: обводка и заливка\n-   В случае точечных данных применяются не к самой точке, а используемой для ее отображения фигуре.\n\nОбщий алгоритм для обводки:\n\n1.  Установить тип отображаемого объекта\n2.  Организовать обход по всем уровням вложенности с помощью цикла\n3.  На самом низком уровне вложенности получить матрицу координат.\n4.  Последовательно соединяя соседние координаты в матрице, отрисовать границу отрезками.\n\n## Отрисовка отрезков\n\n**Алгоритм Брезенхема** [@bresenham1965]\n\n`draw_line(i0, j0, i1, j1, image, color)`\n\n![](images/bresenham.gif){width=\"55%\"}\n\n## Алгоритм Брезенхэма\n\nCистема экранных координат $ij$, где $i$ — строка (увеличивается сверху вниз), $j$ — столбец (увеличивается слева направо),\n\n-   $(i_0, j_0)$ — начальная точка отрезка в экранных координатах\n-   $(i_1, j_1)$ — конечная точка отрезка в экранных координатах\n\nУравнение отрезка: $$\\frac{i - i_0}{i_1-i_0} = \\frac{j - j_0}{j_1-j_0}$$\n\nВыразив $i$, получаем: $$i = \\color{red}{\\underbrace{\\frac{i_1 - i_0}{j_1-j_0}}_{\\textbf{d (уклон)}}} (j - j_0) + i_0$$\n\n## Отрисовка отрезков\n\n::: columns\n::: {.column width=\"40%\"}\n*Стандартно* рассматривается отрисовка линии, которая располагается в секторе `В-ЮВ`, т.е. идет относительно начальной точки вправо и полого вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 < j_1,~i_0 \\leq i_1$;\n-   $j_1 - j_0 \\geq i_1 - i_0$.\n:::\n\n::: {.column width=\"60%\"}\n![](images/coords.png){width=\"100%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `В-ЮВ` алгоритм опирается на координаты $x$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n-   $dj = j_1 - j_0$.\n-   $di = i_1 - i_0$.\n-   $\\color{blue}{d = di / dj}$;\n-   $\\color{blue}{i = i_0}$;\n-   $e = 0$\n:::\n\n::: {.column width=\"50%\"}\n**Для** $\\color{blue}{j = j_0, ... j_1}$, **выполняем**:\n\n1.  Рисуем пиксель $(i, j)$.\n2.  Обновляем ошибку $e = e + |d|$.\n3.  Если $e \\geq 0.5$, то:\n\n-   $\\color{blue}{i = i + \\texttt{sign}(di)}$,\n-   $e = e - 1$.\n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `В-СВ` (только $i$ будет уменьшаться).\n\nОбозначим случай `draw_line_byJ(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\n::: columns\n::: {.column width=\"50%\"}\n*Альтернативно* рассматривается отрисовка линии, которая располагается в секторе `Ю-ЮВ`, т.е. идет относительно начальной точки вправо и круто вниз при соблюдении следующих условий:\n\n-   $j_0 \\geq 0,~i_0 \\geq 0$;\n-   $j_0 \\leq j_1,~i_0 < i_1$;\n-   $j_1 - j_0 < i_1 - i_0$.\n:::\n\n::: {.column width=\"50%\"}\n![](images/coords2.png){width=\"55%\"}\n:::\n:::\n\n## Алгоритм Брезенхэма\n\nДля сектора `Ю-ЮВ` алгоритм опирается на координаты $i$:\n\n::: columns\n::: {.column width=\"50%\"}\n**Вычисляем заранее**:\n\n-   $dj = j_1 - j_0$.\n-   $di = i_1 - i_0$.\n-   $\\color{red}{d = dj / di}$;\n-   $\\color{red}{j = j_0}$;\n-   $e = 0$\n:::\n\n::: {.column width=\"50%\"}\n**Для** $\\color{red}{i = i_0, ... i_1}$ **выполняем**:\n\n1.  Рисуем пиксель $(i, j)$.\n2.  Обновляем ошибку $e = e + |d|$.\n3.  Если $e \\geq 0.5$, то:\n\n-   $\\color{red}{j = j + \\texttt{sign}(dj)}$,\n-   $e = e - 1$.\n:::\n:::\n\nИспользование функции $\\texttt{sign}$ позволяет применять алгоритм также и для сектора `Ю-ЮЗ` (только $j$ будет уменьшаться).\n\nОбозначим случай `draw_line_byI(i0, j0, i1, j1, image, color)`\n\n## Алгоритм Брезенхэма\n\nДля оставшихся направлений построение линий реализуется путем перестановки местами начальной и конечной точки. Код результирующей функции на **Python**:\n\n```         \ndef draw_line(i0, j0, i1, j1, image, color):\n    if abs(i1 - i0) < abs(j1 - j0): # пологая линия\n        if j0 > j1:\n            draw_line_byJ(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byJ(i0, j0, i1, j1, image, color)\n    else:\n        if i0 > i1:                 # крутая линия\n            draw_line_byI(i1, j1, i0, j0, image, color)\n        else:\n            draw_line_byI(i0, j0, i1, j1, image, color)\n```\n\nгде `abs()` — функция вычисления модуля.\n\n## Заливка полигона\n\n![](images/polyfill.png){width=\"70%\"}\n\n## Алгоритм сканирующей линии\n\nДля каждого $i_k = i_{min},...,i_{max}$ получить упорядоченное по возрастанию множество $J = \\{j_0, j_1, ..., j_{n-1}\\}$ столбцов пересечений с исходными линиями:\n\n1.  Для каждой линии $l_m, m = 0,...,N-1$:\n\n-   вычислить флаг пересечения $f: i^m_0 > i_k \\neq i^m_1 > i_k$;\n-   если $f = \\texttt{TRUE}$, то\n    -   вычислить $j^m = j^m_0 + (j^m_1 - j^m_0)\\frac{i_k - i^m_0}{i^m_1 - i^m_0}$;\n    -   добавить $j^m$ в множество $J$.\n\n2.  Если $J$ не пусто, то упорядочить его по возрастанию и выполнить закрашивание между его элементами в порядке:\n\n$$\\lceil j_0 \\rceil \\to \\lfloor j_1 \\rfloor,~\\lceil j_2 \\rceil \\to \\lfloor j_3 \\rfloor,~...~,~\\lceil j_{n-2} \\rceil \\to \\lfloor j_{n-1} \\rfloor$$\n\n## Отсечение отрезков\n\nОдин из самых широко используемых — **алгоритм Коэна-Сазерленда**, в котором используется разбиение плоскости на 9 частей прямыми, координаты которых определяются границами прямоугольника (в частности — порта просмотра):\n\n::: columns\n::: {.column width=\"50%\"}\n![](images/cohen_sutherland.svg){width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n-   `INSIDE = 0` — $0000$\n-   `LEFT = 1` — $0001$\n-   `RIGHT = 2` — $0010$\n-   `BOTTOM = 4` — $0100$\n-   `TOP = 8` — $1000$\n\nОтрезки, обе точки которых находятся по одну сторону от прямоугольника, имеют совпадающий единичный бит в одной и той же позиции\n:::\n:::\n\n## Вычисление кодов Коэна-Сазерленда\n\nПусть дана точка $(i, j)$, а также границы порта просмотра $(i_{min}, i_{max})$, $(j_{min}, j_{max})$.\n\nТогда код вычисляется следующим образом:\n\n```         \ndef code(i, j, imax, jmax):\n    code = INSIDE\n    if j < jmin:\n        code |= LEFT\n    elif j > jmax:\n        code |= RIGHT\n    if i < imin:\n        code |= BOTTOM\n    elif i > imax:\n        code |= TOP\n    return code\n```\n\nВ данном случае применяется операция *логическое ИЛИ*, которая устанавливает в каждый бит $1$, если хотя бы у одного из операндов соответствующий бит равен $1$.\n\n## Алгоритм Коэна-Сазерленда\n\nДля каждого отрезка $(i_0, j_0), (i_1, j_1)$ выполняется бесконечный цикл, внутри которого ведутся следующие действия:\n\n1.  Вычисляются коды `code0` и `code1` для концов отрезка.\n\n2.  Если оба конца находятся внутри порта просмотра (`code0 | code1 == 0`), то отрезок принимается целиком и цикл прерывается.\n\n3.  Если оба конца находятся по одну сторону от порта просмотра (`code0 & code1 != 0`), то отрезок отклоняется целиком и цикл прерывается.\n\n4.  В противном случае (оба конца находятся по разные стороны от порта просмотра), выполняются следующие действия:\n\n    -   Выбирается любая точка, находящаяся за пределами порта просмотра.\n    -   Выполняется пересечение отрезка с прямой, определяющей ту сторону, в которой находится выбранная точка.\n    -   Выбранная точка заменяется на найденное пересечение.\n    \n## Аффинные преобразования\n\n**Аффинное преобразование** $f\\colon\\mathbb{R}^{n}\\to \\mathbb{R}^{n}$ есть преобразование вида:\n\n$$\nf(\\mathrm p) = \\mathbf M \\cdot \\mathrm p + \\mathrm v\n$$\n\nгде $\\mathbf M$ --- *обратимая матрица* (квадратная матрица, определитель которой отличен от нуля) и $v\\in \\mathbb{R}^{n}$.\n\n$\\mathbf M$ и $\\mathrm v$ обычно объединяются в одну матрицу $\\mathbf A$, что требует представления $p$ в *однородных* координатах: $\\widehat{\\mathrm p} = (x_p, y_p,..., 1)$. В этом случае аффинное преобразование можно записать как:\n\n$$\nf(\\mathrm p) = \\mathbf A \\cdot \\widehat{\\mathrm p} = \\left[ \\begin{array}{ccc|c} \\, & \\mathbf M & & \\mathrm v \\ \\\\ 0 & \\ldots & 0 & 1 \\end{array} \\right] \\begin{bmatrix} \\mathrm p \\\\ 1 \\end{bmatrix}\n$$\n\n## Аффинные преобразования\n\n**Сдвиг** на вектор трансляции $t = (t_x, t_y)$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} 1 &  0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf T(t_x, t_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1x + 0y + t_x1 \\\\ 0x + 1y + t_y1 \\\\ 0x + 0y + 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix},\n$$\n\n**Поворот** на угол $\\theta$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 0 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} \\cos \\theta &  -\\sin \\theta & 0 \\\\ \\sin \\theta & \\cos \\theta  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf R(\\theta)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta \\\\ x \\sin \\theta + y \\cos \\theta \\\\ 1 \\end{bmatrix},\n$$\n\n## Аффинные преобразования\n\n**Масштабирование** с коэффициентами $s_x, s_y$:\n\n$$\n\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\underbrace{\\begin{bmatrix} s_x &  0 & 0 \\\\ 0 & s_y  & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\mathbf S(s_x, s_y)} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x s_x \\\\ y s_y \\\\ 1 \\end{bmatrix},\n$$\n- при навигации по карте $s_x = s_y = a$\n- для зеркального отражения по соответствующим осям $s_x$ или $s_y$ будут иметь отрицательные значения.\n\n## Стандартные сценарии\n\nПри загрузке слоя данных в пустой проект объекты вписываются в порт просмотра.\n\nПусть ограничивающий прямоугольник (_экстент_) данных имеет размеры $[x_0, y_0]\\times[x_1, y_1]$, а размер порта просмотра $[0, di]\\times[0, dj]$. Тогде необходимо выполнить следующие преобразования:\n\n- Совместить начало координат с центром экстента данных — точкой $[(x_1 + x_0)/2, (y_1 + y_0)/2]$.\n\n- На овнове сравнения пропорций экстента $\\frac{dx}{dy}$ и порта просмотра $\\frac{di}{dj}$ выбрать коэффициент масштабирования $s$:\n\n$$s = \\begin{cases}\n\\frac{di}{dx},~\\texttt{если}~\\frac{dx}{dy} \\leq \\frac{di}{dj}\\\\\n\\frac{dj}{dy},~\\texttt{если}~\\frac{dx}{dy} > \\frac{di}{dj}\\\\\n\\end{cases}$$\n\n## Стандартные сценарии\n\n- Отмасштабировать координаты на полученный коэффициент $s$.\n\n- Переместить отмасштабированное изображение в точку $(di/2, dj/2)$.\n\nИтоговая матрица преобразования $\\textbf{A}$ будет выглядеть следующим образом:\n\n$$\\textbf A = \\textbf T(di/2, dj/2)~\\textbf S(s)~\\textbf T(-(x_1 + x_0)/2, -(y_1 + y_0)/2)$$\n\nТочки исходных объектов $p$ будут трансформированы в точки внутри порта просмотра $p'$ как:\n\n$$p' = \\textbf A p$$\n\n## Стандартные сценарии\n\nПусть текущая матрица отображения равна $A$. Пользователь:\n\n- перетащил изображение из точки $(i_1, j_1)$ в точку $(i_2, j_2)$:\n\n$$\\mathbf A = \\mathbf T(i_2-i_1, j_2 - j_1)\\mathbf A$$\n\n- в точке $(i, j)$ прокрутил колесико мыши на $k > 0$ оборота:\n\n$$\\mathbf A = \\mathbf T(i, j)~\\mathbf S(ks, ks)~\\mathbf T(-i, -j)~\\mathbf A$$\n\n- в точке $(i, j)$ прокрутил колесико мыши на $k < 0$ оборота:\n\n$$\\mathbf A = \\mathbf T(i, j)~\\mathbf S(-\\frac{1}{ks}, -\\frac{1}{ks})~\\mathbf T(-i, -j)~\\mathbf A$$\n\nКаждый оборот соответствует изменению масштаба в $s$ раз. Отрицательные обороты соответствуют уменьшению масштаба, положительные — увеличению.\n\n## Библиография\n\n",
    "supporting": [
      "01_BasicAlgorithms_files"
    ],
    "filters": [],
    "includes": {}
  }
}